<!doctype html>
<html lang="en">
  <head>
  <meta charset="utf-8" />
  <title>Card Placement Funnel</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="./sis-shared.css?v=navfix" />
	  <link rel="stylesheet" href="./assets/css/sis.css">
	  <link rel="stylesheet" href="./assets/css/funnel.css">
	  <script defer src="./assets/js/sis.js"></script>
	  <script defer src="./assets/js/nav.js"></script>
	  <script type="module" defer src="./assets/js/funnel.data.js"></script>
	  <script type="module" defer src="./assets/js/funnel.view.js"></script>
	  <script type="module" defer src="./assets/js/funnel.js"></script>
	  <script type="module" defer src="./assets/js/data-cache.js?v=3"></script>
	  <script defer src="./assets/js/filters.js?v=shared"></script>
	  <script type="module" defer src="./assets/js/raw-data-checker.js"></script>
	  <script>
	    document.addEventListener("DOMContentLoaded", function(){
	      if (window.renderHeaderNav && !window.__sisHeaderNav_funnel) {
	        window.__sisHeaderNav_funnel = true;
	        window.renderHeaderNav({
	          currentId: "funnel",
	          title: "FI Funnel",
	          subtitle: "GA + SIS conversion funnel by FI, partner, integration, and date."
	        });
	      }
	    });
	  </script>
	  <link rel="stylesheet" href="./assets/css/filters.css">
    <style>
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 0;
        font-family: "Inter", "Segoe UI", ui-sans-serif, system-ui, -apple-system, Roboto, "Helvetica Neue", Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        font-size: 16px;
        --sis-panel-bg: var(--panel);
      }
      .sis-panel-title {
        font-size: 1.2rem;
        margin-bottom: 12px;
      }
      .form-grid {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: flex-end;
      }
      .form-grid--dates {
        margin-top: 8px;
      }
      .form-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 160px;
        min-height: 54px;
      }
      .form-field label {
        font-size: 0.85rem;
        color: var(--muted);
        letter-spacing: 0.03em;
        text-transform: uppercase;
        padding-left: 2px;
      }
      .form-input,
      .form-select {
        background: var(--input-bg);
        border: 1px solid var(--input-border);
        border-radius: 10px;
        color: var(--text);
        padding: 10px 12px;
        font-size: 0.92rem;
        min-width: 160px;
        height: 42px;
        line-height: 22px;
        box-sizing: border-box;
      }
      .form-input:focus,
      .form-select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px rgba(37,99,235,0.2);
      }
      .form-actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .form-checkbox label {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 0.85rem;
        color: var(--muted);
        text-transform: none;
        letter-spacing: 0;
      }
      .form-checkbox input[type="checkbox"] {
        width: 16px;
        height: 16px;
        accent-color: var(--accent);
      }
      .form-button {
        background: linear-gradient(120deg, var(--accent), var(--accent-2));
        border: none;
        border-radius: 999px;
        padding: 10px 28px;
        min-width: 170px;
        font-size: 0.9rem;
        cursor: pointer;
        color: #f8fafc;
        font-weight: 600;
        letter-spacing: 0.2px;
      }
      .form-button.secondary {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--muted);
      }
      .group-header {
        margin-top: 16px;
        font-weight: 700;
        font-size: 0.9rem;
      }
      .group-block {
        margin-top: 16px;
      }
      .single-fi-section {
        margin-top: 16px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 0.8rem;
      }
      th,
      td {
        border: 1px solid var(--table-border);
        padding: 5px 7px;
        text-align: left;
      }
      th {
        background: var(--table-header);
        position: sticky;
        top: 0;
        z-index: 2;
      }
      .highlights-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 0.78rem;
      }
      .highlights-table th,
      .highlights-table td {
        border: 1px solid var(--table-border);
        padding: 5px 7px;
        text-align: left;
      }
      .highlights-table th {
        background: var(--table-header);
      }
      .loading-status {
        min-height: 18px;
        font-size: 0.9rem;
        font-weight: 600;
        color: var(--accent);
        margin: 4px 0 8px;
        display: block;
      }
      .quarter-summary {
        margin-top: 12px;
      }
      .quarter-summary table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 8px;
        font-size: 0.8rem;
      }
      .quarter-summary th,
      .quarter-summary td {
        border: 1px solid var(--table-border);
        padding: 5px 7px;
        text-align: left;
      }
      .quarter-summary th {
        background: var(--table-header);
      }
      .highlights-table th:first-child,
      .highlights-table td:first-child {
        min-width: 180px;
      }
      .muted {
        color: var(--muted);
      }
      .tab-bar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 12px;
      }
      .tab-button {
        background: transparent;
        border: 1px solid var(--border);
        color: var(--muted);
        border-radius: 999px;
        padding: 6px 14px;
        font-size: 0.78rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        cursor: pointer;
        transition: background 0.15s ease, color 0.15s ease;
      }
      .tab-button.active {
        background: var(--panel);
        color: var(--text);
        border-color: var(--accent);
      }
      .tab-panel {
        display: none;
        margin-top: 8px;
      }
      .tab-panel.active {
        display: block;
      }
      .tab-panel h3 {
        margin: 0 0 6px;
        font-size: 0.9rem;
        color: var(--muted);
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .totals-row td {
        font-weight: 600;
        border-top: 2px solid var(--table-border);
        background: var(--table-alt);
      }
      .sources-missing {
        font-size: 0.72rem;
        color: #f97316;
      }
      .sources-missing-badge {
        display: inline-block;
        padding: 2px 8px;
        background: #fef3c7;
        color: #92400e;
        border-radius: 4px;
        font-weight: 600;
        cursor: help;
        font-size: 0.75rem;
      }
      .sources-missing-badge:hover {
        background: #fde68a;
      }
      .sources-missing-tooltip {
        position: relative;
      }
      .sources-missing-tooltip .tooltip-content {
        visibility: hidden;
        opacity: 0;
        position: absolute;
        z-index: 1000;
        background-color: #1f2937;
        color: #fff;
        padding: 12px;
        border-radius: 6px;
        font-size: 0.75rem;
        line-height: 1.5;
        white-space: pre-wrap;
        max-width: 400px;
        max-height: 300px;
        overflow-y: auto;
        bottom: 125%;
        left: 50%;
        transform: translateX(-50%);
        transition: opacity 0.2s, visibility 0.2s;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      }
      .sources-missing-tooltip:hover .tooltip-content {
        visibility: visible;
        opacity: 1;
      }
      .sources-missing-tooltip .tooltip-content::after {
        content: "";
        position: absolute;
        top: 100%;
        left: 50%;
        margin-left: -5px;
        border-width: 5px;
        border-style: solid;
        border-color: #1f2937 transparent transparent transparent;
      }
      .funnel-header {
        margin-bottom: 8px;
      }
      .form-actions {
        margin-top: 0;
      }
      .funnel-body {
        padding-top: 4px;
      }
      .funnel-body .group-header:first-of-type {
        margin-top: 0;
      }
      .date-window {
        display: inline-flex;
        align-items: center;
        height: 28px;
        padding: 0 8px;
        margin-left: 8px;
        font-size: 0.9rem;
        background: var(--panel-light);
        border-radius: 12px;
        border: 1px solid var(--border);
      }
      .partner-summary {
        margin-top: 16px;
        padding: 16px;
        border-radius: 14px;
        border: 1px solid var(--table-border);
        background: var(--panel-light);
      }
      .partner-summary h3 {
        margin: 0 0 8px;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 0.85rem;
        color: var(--muted);
      }
      .partner-summary p {
        margin: 0 0 12px;
        color: var(--muted);
        font-size: 0.8rem;
      }
      .partner-summary__table {
        width: 100%;
        border-collapse: collapse;
      }
      .partner-summary__table th,
      .partner-summary__table td {
        border: 1px solid var(--table-border);
        padding: 6px 8px;
        text-align: left;
        font-size: 0.78rem;
      }
      .partner-summary__table th {
        background: var(--table-header);
        position: static;
      }
      .partner-summary__table tfoot td {
        font-weight: 600;
      }
      .date-warning {
        margin: 4px 0 0;
        color: #f97316;
        font-size: 0.9rem;
        display: none;
      }
      .date-warning a {
        color: inherit;
        text-decoration: underline;
      }
      .loading-banner {
        display: flex;
        align-items: center;
        gap: 10px;
        padding: 10px 12px;
        border: 1px solid #f59e0b;
        border-radius: 12px;
        background: rgba(245, 158, 11, 0.12);
        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.08);
        color: #92400e;
        font-size: 13px;
        margin-bottom: 10px;
        visibility: hidden;
        position: sticky;
        top: 0;
        z-index: 5;
        width: 100%;
        box-sizing: border-box;
      }
      .loading-banner .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid #f59e0b;
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        flex-shrink: 0;
      }
      @keyframes spin {
        to { transform: rotate(360deg); }
      }

      /* Conversion Analysis Panel */
      .conversion-analysis-panel {
        margin-top: 16px;
        margin-bottom: 24px;
        padding: 20px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: var(--panel-light);
      }
      .conversion-header {
        margin: 0 0 16px;
        font-weight: 700;
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: var(--text);
      }
      .conversion-grid {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 16px;
        margin-bottom: 24px;
      }
      @media (max-width: 1024px) {
        .conversion-grid {
          grid-template-columns: repeat(2, 1fr);
        }
      }
      .conversion-metric {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 14px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 14px 34px rgba(0, 0, 0, 0.12);
        transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
      }
      .conversion-metric:hover {
        transform: translateY(-1px);
        border-color: var(--accent);
        box-shadow: 0 18px 42px rgba(0, 0, 0, 0.16);
      }
      .conversion-metric.with-jobs-theme {
        --with-jobs-accent: #4a9eba;
        background:
          linear-gradient(
            135deg,
            rgba(74, 158, 186, 0.16) 0%,
            rgba(74, 158, 186, 0.06) 55%,
            rgba(74, 158, 186, 0) 100%
          ),
          var(--panel);
        border-color: rgba(74, 158, 186, 0.55);
      }
      .conversion-metric.with-jobs-theme::before {
        content: "";
        position: absolute;
        left: 0;
        top: 0;
        bottom: 0;
        width: 4px;
        background: linear-gradient(
          180deg,
          rgba(74, 158, 186, 0.95),
          rgba(74, 158, 186, 0.15)
        );
      }
      .metric-label {
        font-size: 0.75rem;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 8px;
      }
      .metric-value {
        font-size: 1.8rem;
        font-weight: 700;
        color: var(--text);
        margin-bottom: 4px;
      }
      .metric-pct {
        font-size: 0.85rem;
        color: var(--muted);
        font-weight: 600;
      }
      .conversion-breakdown {
        border-top: 1px solid var(--border);
        padding-top: 20px;
      }
      .breakdown-header {
        font-weight: 700;
        font-size: 0.9rem;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: var(--text);
        margin-bottom: 14px;
      }
      .breakdown-grid {
        display: grid;
        gap: 10px;
      }
      .breakdown-item {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
        padding: 10px 12px;
      }
      .breakdown-label {
        font-size: 0.85rem;
        font-weight: 600;
        color: var(--text);
        margin-bottom: 6px;
      }
      .breakdown-value {
        font-size: 1.4rem;
        font-weight: 700;
        color: var(--text);
        display: inline-block;
        margin-right: 8px;
      }
      .breakdown-pct {
        font-size: 0.9rem;
        color: var(--muted);
        font-weight: 600;
        display: inline-block;
      }
      .breakdown-bar {
        margin-top: 6px;
        height: 6px;
        background: var(--surface);
        border-radius: 4px;
        overflow: hidden;
      }
      .breakdown-bar-fill {
        height: 100%;
        transition: width 0.3s ease;
        border-radius: 4px;
      }
      .breakdown-bar-success {
        background: linear-gradient(90deg, #22c55e, #16a34a);
      }
      .breakdown-bar-system {
        background: linear-gradient(90deg, #f59e0b, #d97706);
      }
      .breakdown-bar-ux {
        background: linear-gradient(90deg, #ef4444, #dc2626);
      }
      .breakdown-bar-nojobs {
        background: linear-gradient(90deg, #94a3b8, #64748b);
      }

      /* Placement Details Expandable Sections */
      .placement-details {
        margin-top: 10px;
        border-top: 1px solid var(--border);
        padding-top: 8px;
      }

      .placement-summary {
        cursor: pointer;
        padding: 6px 10px;
        font-weight: 600;
        font-size: 0.82rem;
        color: var(--accent);
        list-style: none;
        border-radius: 6px;
        transition: background 0.2s ease;
      }

      .placement-summary:hover {
        background: var(--panel-light);
      }

      .placement-summary::-webkit-details-marker {
        display: none;
      }

      .placement-summary::before {
        content: "▸";
        display: inline-block;
        margin-right: 6px;
        transition: transform 0.2s ease;
      }

      .placement-details[open] .placement-summary::before {
        transform: rotate(90deg);
      }

      .placement-content {
        margin-top: 8px;
        max-width: 100%;
        overflow: hidden;
      }

      .placement-loading {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 12px;
        justify-content: center;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .placement-loading .spinner {
        width: 20px;
        height: 20px;
        border: 2px solid var(--border);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
      }

      .placement-error {
        padding: 10px;
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.3);
        border-radius: 8px;
        color: #ef4444;
        font-size: 0.82rem;
      }

      /* Placement Details - Card-based Layout (matching troubleshoot.html) */
      .placement-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 6px;
      }

      .placement-group {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px;
        box-shadow: 0 16px 40px rgba(15, 23, 42, 0.10);
      }

      .placement-group-header {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
        margin-bottom: 0;
        padding: 0 8px;
        cursor: pointer;
        user-select: none;
        border-radius: 6px;
        transition: background 0.2s;
      }

      .placement-group-header:hover {
        background: var(--hover-bg, rgba(0, 0, 0, 0.02));
      }

      [data-theme="dark"] .placement-group-header:hover {
        background: rgba(255, 255, 255, 0.05);
      }

      .placement-group-toggle {
        font-size: 0.9rem;
        color: var(--muted);
        margin-right: 4px;
        transition: transform 0.2s;
      }

      .placement-group.collapsed .placement-group-toggle {
        transform: rotate(-90deg);
      }

      .placement-group-merchant {
        font-weight: 600;
        color: var(--text);
        font-size: 1rem;
      }

      .placement-group-count {
        display: inline-flex;
        align-items: center;
        background: var(--chip-bg);
        color: var(--chip-text);
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.75rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .placement-count-success {
        background: rgba(22,163,74,0.12);
        color: #16a34a;
      }

      [data-theme="dark"] .placement-count-success {
        background: rgba(34,197,94,0.15);
        color: #4ade80;
      }

      .placement-count-system {
        background: rgba(245,158,11,0.15);
        color: #d97706;
      }

      [data-theme="dark"] .placement-count-system {
        background: rgba(251,191,36,0.15);
        color: #fbbf24;
      }

      .placement-count-ux {
        background: rgba(239,68,68,0.12);
        color: #dc2626;
      }

      [data-theme="dark"] .placement-count-ux {
        background: rgba(248,113,113,0.15);
        color: #f87171;
      }

      .placement-items {
        display: flex;
        flex-direction: column;
        gap: 6px;
        margin-top: 0;
      }

      .placement-group.collapsed .placement-items {
        display: none;
      }

      .placement-item {
        border: 1px solid var(--border);
        border-radius: 8px;
        padding: 8px 10px;
        background: var(--panel-light);
      }

      .placement-item-header {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        align-items: center;
        margin-bottom: 4px;
      }

      .placement-chip {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        background: var(--panel-light);
        color: var(--muted);
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 0.78rem;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }


      .badge {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border-radius: 999px;
        padding: 4px 9px;
        font-size: 0.78rem;
        letter-spacing: 0.02em;
        font-weight: 600;
      }

      .badge.success {
        background: rgba(22,163,74,0.12);
        color: var(--badge-success);
      }

      .badge.fail {
        background: rgba(220,38,38,0.12);
        color: var(--badge-fail);
      }

      .badge.warn {
        background: rgba(245,158,11,0.15);
        color: var(--badge-warn);
      }

      .badge.ux {
        background: rgba(59,130,246,0.08);
        color: var(--accent);
      }

      .badge.neutral {
        background: var(--panel);
        color: var(--muted);
        border: 1px solid var(--border);
      }

      .placement-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        font-size: 0.8rem;
        color: var(--muted);
      }

      .placement-meta strong {
        color: var(--text);
      }

      .raw-details {
        margin-top: 8px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--panel-light);
      }

      .raw-details summary {
        cursor: pointer;
        padding: 8px 10px;
        font-weight: 600;
        color: var(--muted);
        list-style: none;
        font-size: 0.8rem;
      }

      .raw-details summary::-webkit-details-marker {
        display: none;
      }

      .raw-details summary::before {
        content: "▸";
        display: inline-block;
        margin-right: 6px;
        transform: translateY(-1px);
      }

      .raw-details[open] summary::before {
        content: "▾";
      }

      .raw-block {
        padding: 0 12px 12px;
        overflow: auto;
        max-height: 360px;
        font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 0.85rem;
        color: var(--muted);
        white-space: pre;
      }

      /* JSON syntax highlighting in raw blocks */
      .raw-block .json-key {
        color: #9cdcfe;
      }

      .raw-block .json-string {
        color: #ce9178;
      }

      .raw-block .json-number {
        color: #b5cea8;
      }

      .raw-block .json-boolean {
        color: #569cd6;
      }

      .raw-block .json-null {
        color: #569cd6;
      }

      .show-all-btn {
        margin-top: 12px;
        padding: 8px 16px;
        background: var(--accent);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      .show-all-btn:hover {
        background: var(--accent-2);
      }

      .show-all-btn:disabled {
        background: var(--border);
        color: var(--muted);
        cursor: not-allowed;
      }

      .placement-empty {
        padding: 20px;
        text-align: center;
        color: var(--muted);
        font-size: 0.9rem;
        border: 1px dashed var(--border);
        border-radius: 8px;
        background: var(--panel-light);
      }

      /* Filter Controls Above Card List */
      .placement-filters {
        margin-bottom: 12px;
        padding: 12px;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 10px;
      }

      .placement-filter-row {
        display: flex;
        flex-wrap: wrap;
        gap: 12px;
        align-items: center;
      }

      .placement-filter-label {
        font-size: 0.85rem;
        color: var(--muted);
        letter-spacing: 0.03em;
        text-transform: uppercase;
        font-weight: 600;
        margin-right: 8px;
      }

      /* Column Filter Dropdowns */
      .column-filter-wrapper {
        position: relative;
        display: inline-block;
      }

      .column-filter-toggle {
        cursor: pointer;
        user-select: none;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 6px 12px;
        background: var(--panel-light);
        border: 1px solid var(--border);
        border-radius: 6px;
        font-size: 0.85rem;
        transition: all 0.15s ease;
      }

      .column-filter-toggle:hover {
        background: var(--surface);
        border-color: var(--accent);
      }

      .column-filter-toggle::after {
        content: '▾';
        font-size: 0.7rem;
        opacity: 0.6;
      }

      .column-filter-dropdown {
        position: absolute;
        top: 100%;
        left: 0;
        margin-top: 4px;
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        padding: 8px;
        min-width: 200px;
        max-width: 300px;
        max-height: 300px;
        overflow-y: auto;
        z-index: 1000;
        display: none;
      }

      .column-filter-dropdown.active {
        display: block;
      }

      .column-filter-option {
        padding: 6px 8px;
        margin: 2px 0;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.15s ease;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.85rem;
      }

      .column-filter-option:hover {
        background: var(--panel-light);
      }

      .column-filter-option input[type="checkbox"] {
        cursor: pointer;
      }

      .column-filter-option label {
        cursor: pointer;
        flex: 1;
        user-select: none;
      }

      .column-filter-controls {
        display: flex;
        gap: 8px;
        padding: 8px 8px 4px 8px;
        border-bottom: 1px solid var(--border);
        margin-bottom: 4px;
      }

      .column-filter-controls button {
        flex: 1;
        padding: 4px 8px;
        background: var(--panel-light);
        color: var(--text);
        border: 1px solid var(--border);
        border-radius: 4px;
        font-size: 0.75rem;
        cursor: pointer;
        transition: all 0.15s ease;
      }

      .column-filter-controls button:hover {
        background: var(--surface);
        border-color: var(--accent);
      }

      .column-filter-count {
        display: inline-block;
        margin-left: 4px;
        padding: 2px 6px;
        background: var(--accent);
        color: white;
        border-radius: 10px;
        font-size: 0.7rem;
        font-weight: 600;
      }
    </style>
	  </head>
	  <body>
	    <div id="sis-header"></div>
	  <div class="sis-content">
	  <main class="sis-main">
      <section class="sis-panel">
        <div id="pageLoader" class="loading-banner">
          <div class="spinner" aria-hidden="true"></div>
          <div class="loading-text">Loading data…</div>
        </div>
        <div id="filter-bar"></div>
        <div class="funnel-header">
          <div class="form-grid form-grid--dates">
            <div class="form-field">
              <label for="datePreset">Range preset</label>
              <select id="datePreset" class="form-select">
                <option value="last7" selected>Last 7 days</option>
                <option value="last14">Last 14 days</option>
                <option value="last30">Last 30 days</option>
                <option value="last60">Last 60 days</option>
                <option value="last90">Last 90 days</option>
                <option value="ytd">Year to date</option>
                <option value="">Custom</option>
              </select>
            </div>
            <div class="form-field">
              <label for="startDate">Start date</label>
              <input id="startDate" type="date" class="form-input" />
            </div>
            <div class="form-field">
              <label for="endDate">End date</label>
              <input id="endDate" type="date" class="form-input" />
            </div>
            <div class="form-field" style="min-width: 200px">
              <label for="applyBtn">Actions</label>
              <div class="form-actions">
                <button id="applyBtn" class="form-button">Apply filters</button>
                <button id="exportCsvBtn" class="form-button secondary">Export CSV</button>
                <label class="form-checkbox" style="margin: 0">
                  <input type="checkbox" id="includeTestDataCheckbox" />
                  Include test data
                </label>
              </div>
            </div>
          </div>
          <div id="dateWarning" class="date-warning" aria-live="polite"></div>
        </div>

    <div class="funnel-body">
      <div class="group-header">Highlights <span class="muted date-window" id="dateWindowLabel"></span></div>
      <div id="bestWindows" style="margin-bottom: 8px;"></div>
      <div id="totalsBar" class="group-header" style="display: none;"></div>
      <div id="partnerSummary" class="partner-summary" style="display: none;"></div>

      <div id="conversionAnalysis" class="conversion-analysis-panel" style="display: none;">
        <div class="conversion-header">Session Conversion & Failure Analysis</div>
        <div class="conversion-grid">
          <div class="conversion-metric">
            <div class="metric-label">Unique CardUpdatr Views</div>
            <div class="metric-value" id="convMetricGaSelect">-</div>
          </div>
          <div class="conversion-metric">
            <div class="metric-label">Total Sessions</div>
            <div class="metric-value" id="convMetricTotalSessions">-</div>
            <div class="metric-pct" id="convMetricSessionsPct">-</div>
          </div>
          <div class="conversion-metric">
            <div class="metric-label">Sessions w/o Jobs (Abandoned)</div>
            <div class="metric-value" id="convMetricNoJobs">-</div>
            <div class="metric-pct" id="convMetricNoJobsPct">-</div>
          </div>
          <div class="conversion-metric with-jobs-theme">
            <div class="metric-label">Total Jobs</div>
            <div class="metric-value" id="convMetricTotalJobs">-</div>
          </div>
          <div class="conversion-metric with-jobs-theme">
            <div class="metric-label">Sessions w/ Jobs</div>
            <div class="metric-value" id="convMetricWithJobs">-</div>
            <div class="metric-pct" id="convMetricWithJobsPct">-</div>
          </div>
          <div class="conversion-metric with-jobs-theme">
            <div class="metric-label">Sessions w/ Successful Jobs</div>
            <div class="metric-value" id="convMetricSuccessfulSessions">-</div>
            <div class="metric-pct" id="convMetricSuccessfulSessionsPct">-</div>
          </div>
          <div class="conversion-metric with-jobs-theme funnel-dist-card" data-sis-card="attempts">
            <div class="funnel-dist-header">
              <div class="metric-label">Merchant Attempts (sess w/ jobs)</div>
              <button class="funnel-dist-toggle" id="toggle-distribution" data-sis-action="distribution" type="button" aria-expanded="false" aria-label="Show distribution ▾">Show distribution ▾</button>
            </div>
            <div class="funnel-dist-row chips-row" aria-label="Merchant attempts stats">
              <span class="funnel-dist-chip ui-chip" data-chip="median" title="Median jobs per session (sessions with jobs)" aria-label="Median jobs per session (sessions with jobs)"><b>MEDIAN</b><span class="funnel-dist-value" data-key="median">—</span></span>
              <span class="funnel-dist-chip ui-chip" data-chip="p75" title="75th percentile of jobs per session (sessions with jobs)" aria-label="75th percentile of jobs per session (sessions with jobs)"><b>P75</b><span class="funnel-dist-value" data-key="p75">—</span></span>
              <span class="funnel-dist-chip ui-chip" data-chip="avg" title="Average jobs per session (sessions with jobs)" aria-label="Average jobs per session (sessions with jobs)"><b>AVG</b><span class="funnel-dist-value" data-key="avg">—</span></span>
            </div>
            <div class="funnel-dist-panel" id="distribution-wrap" tabindex="-1" aria-label="Jobs per session distribution" hidden>
              <table class="funnel-dist-table">
                <thead>
                  <tr>
                    <th>Jobs per session</th>
                    <th>Sessions</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
              <div class="funnel-dist-empty" hidden>No distribution available for current filters.</div>
            </div>
          </div>
          <div class="conversion-metric with-jobs-theme">
            <div class="metric-label">Avg Successful Jobs Per Session</div>
            <div class="metric-value" id="convMetricAvgSuccessfulJobs">-</div>
          </div>
        </div>

        <div class="conversion-breakdown">
          <div class="breakdown-header">Job Outcome Breakdown</div>
          <div class="breakdown-grid">
            <div class="breakdown-item breakdown-success">
              <div class="breakdown-label">✓ Successful</div>
              <div class="breakdown-value" id="convBreakdownSuccess">-</div>
              <div class="breakdown-pct" id="convBreakdownSuccessPct">-</div>
              <div class="breakdown-bar">
                <div class="breakdown-bar-fill breakdown-bar-success" id="convBarSuccess" style="width: 0%;"></div>
              </div>

              <details class="placement-details" data-type="success">
                <summary class="placement-summary">View successful placements</summary>
                <div class="placement-content">
                  <div class="placement-loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Loading placements...</span>
                  </div>
                  <div class="placement-error" style="display: none;"></div>
                  <div class="placement-table-container"></div>
                </div>
              </details>
            </div>
            <div class="breakdown-item breakdown-system">
              <div class="breakdown-label">⚠ System Failures</div>
              <div class="breakdown-value" id="convBreakdownSystem">-</div>
              <div class="breakdown-pct" id="convBreakdownSystemPct">-</div>
              <div class="breakdown-bar">
                <div class="breakdown-bar-fill breakdown-bar-system" id="convBarSystem" style="width: 0%;"></div>
              </div>

              <details class="placement-details" data-type="system">
                <summary class="placement-summary">View system failures</summary>
                <div class="placement-content">
                  <div class="placement-loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Loading placements...</span>
                  </div>
                  <div class="placement-error" style="display: none;"></div>
                  <div class="placement-table-container"></div>
                </div>
              </details>
            </div>
            <div class="breakdown-item breakdown-ux">
              <div class="breakdown-label">⊗ UX Failures</div>
              <div class="breakdown-value" id="convBreakdownUX">-</div>
              <div class="breakdown-pct" id="convBreakdownUXPct">-</div>
              <div class="breakdown-bar">
                <div class="breakdown-bar-fill breakdown-bar-ux" id="convBarUX" style="width: 0%;"></div>
              </div>

              <details class="placement-details" data-type="ux">
                <summary class="placement-summary">View UX failures</summary>
                <div class="placement-content">
                  <div class="placement-loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Loading placements...</span>
                  </div>
                  <div class="placement-error" style="display: none;"></div>
                  <div class="placement-table-container"></div>
                </div>
              </details>
            </div>
            <div class="breakdown-item breakdown-nojobs">
              <div class="breakdown-label">⊘ Sessions Without Jobs</div>
              <div class="breakdown-value" id="convBreakdownNoJobs">-</div>
              <div class="breakdown-pct" id="convBreakdownNoJobsPct">-</div>
              <div class="breakdown-bar">
                <div class="breakdown-bar-fill breakdown-bar-nojobs" id="convBarNoJobs" style="width: 0%;"></div>
              </div>

              <details class="placement-details" data-type="nojobs">
                <summary class="placement-summary">View sessions without jobs</summary>
                <div class="placement-content">
                  <div class="placement-loading" style="display: none;">
                    <div class="spinner"></div>
                    <span>Loading sessions...</span>
                  </div>
                  <div class="placement-error" style="display: none;"></div>
                  <div class="placement-table-container"></div>
                </div>
              </details>
            </div>
          </div>
        </div>
      </div>

      <div id="multiFiView">
      <div class="group-block" data-group="SSO">
        <div class="group-header">SSO</div>
        <table id="table-SSO">
        <thead>
          <tr>
            <th data-sort-key="fi" data-col="fi">FI</th>
            <th data-sort-key="instances" data-col="instances">instances</th>
            <th data-sort-key="integration" data-col="integration">integration</th>
            <th data-sort-key="ga_select" data-col="ga_select">GA select</th>
            <th data-sort-key="ga_user" data-col="ga_user">GA user</th>
            <th data-sort-key="ga_cred" data-col="ga_cred">GA cred</th>
            <th data-sort-key="reach" data-col="reach">monthly reach %</th>
            <th data-sort-key="sel_user_pct" data-col="sel_user_pct">sel→user %</th>
            <th data-sort-key="sel_cred_pct" data-col="sel_cred_pct">sel→cred %</th>
            <th data-sort-key="sel_success_pct" data-col="sel_success_pct">sel→success %</th>
            <th data-sort-key="sessions" data-col="sessions">sessions</th>
            <th data-sort-key="sess_with_jobs" data-col="sess_with_jobs">sess w/jobs</th>
            <th data-sort-key="sess_jobs_pct" data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-sort-key="sess_with_success" data-col="sess_with_success">sess w/success</th>
            <th data-sort-key="sess_success_pct" data-col="sess_success_pct">sess→success %</th>
            <th data-sort-key="placements" data-col="placements">placements</th>
            <th data-sort-key="sources_missing" data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>

      <div class="group-block" data-group="NON-SSO">
        <div class="group-header">NON-SSO</div>
        <table id="table-NON-SSO">
        <thead>
          <tr>
            <th data-sort-key="fi" data-col="fi">FI</th>
            <th data-sort-key="instances" data-col="instances">instances</th>
            <th data-sort-key="integration" data-col="integration">integration</th>
            <th data-sort-key="ga_select" data-col="ga_select">GA select</th>
            <th data-sort-key="ga_user" data-col="ga_user">GA user</th>
            <th data-sort-key="ga_cred" data-col="ga_cred">GA cred</th>
            <th data-sort-key="reach" data-col="reach">monthly reach %</th>
            <th data-sort-key="sel_user_pct" data-col="sel_user_pct">sel→user %</th>
            <th data-sort-key="sel_cred_pct" data-col="sel_cred_pct">sel→cred %</th>
            <th data-sort-key="sel_success_pct" data-col="sel_success_pct">sel→success %</th>
            <th data-sort-key="sessions" data-col="sessions">sessions</th>
            <th data-sort-key="sess_with_jobs" data-col="sess_with_jobs">sess w/jobs</th>
            <th data-sort-key="sess_jobs_pct" data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-sort-key="sess_with_success" data-col="sess_with_success">sess w/success</th>
            <th data-sort-key="sess_success_pct" data-col="sess_success_pct">sess→success %</th>
            <th data-sort-key="placements" data-col="placements">placements</th>
            <th data-sort-key="sources_missing" data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>

      <div class="group-block" data-group="CardSavr">
        <div class="group-header">CardSavr</div>
        <table id="table-CardSavr">
        <thead>
          <tr>
            <th data-col="fi">FI</th>
            <th data-col="instances">instances</th>
            <th data-col="integration">integration</th>
            <th data-col="ga_select">GA select</th>
            <th data-col="ga_user">GA user</th>
            <th data-col="ga_cred">GA cred</th>
            <th data-col="reach">monthly reach %</th>
            <th data-col="sel_user_pct">sel→user %</th>
            <th data-col="sel_cred_pct">sel→cred %</th>
            <th data-col="sel_success_pct">sel→success %</th>
            <th data-col="sessions">sessions</th>
            <th data-col="sess_with_jobs">sess w/jobs</th>
            <th data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-col="sess_with_success">sess w/success</th>
            <th data-col="sess_success_pct">sess→success %</th>
            <th data-col="placements">placements</th>
            <th data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>

      <div class="group-block" data-group="TEST">
        <div class="group-header">TEST</div>
        <table id="table-TEST">
        <thead>
          <tr>
            <th data-col="fi">FI</th>
            <th data-col="instances">instances</th>
            <th data-col="integration">integration</th>
            <th data-col="ga_select">GA select</th>
            <th data-col="ga_user">GA user</th>
            <th data-col="ga_cred">GA cred</th>
            <th data-col="reach">monthly reach %</th>
            <th data-col="sel_user_pct">sel→user %</th>
            <th data-col="sel_cred_pct">sel→cred %</th>
            <th data-col="sel_success_pct">sel→success %</th>
            <th data-col="sessions">sessions</th>
            <th data-col="sess_with_jobs">sess w/jobs</th>
            <th data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-col="sess_with_success">sess w/success</th>
            <th data-col="sess_success_pct">sess→success %</th>
            <th data-col="placements">placements</th>
            <th data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>

      <div class="group-block" data-group="UNKNOWN">
        <div class="group-header">UNKNOWN</div>
        <table id="table-UNKNOWN">
        <thead>
          <tr>
            <th data-col="fi">FI</th>
            <th data-col="instances">instances</th>
            <th data-col="integration">integration</th>
            <th data-col="ga_select">GA select</th>
            <th data-col="ga_user">GA user</th>
            <th data-col="ga_cred">GA cred</th>
            <th data-col="reach">monthly reach %</th>
            <th data-col="sel_user_pct">sel→user %</th>
            <th data-col="sel_cred_pct">sel→cred %</th>
            <th data-col="sel_success_pct">sel→success %</th>
            <th data-col="sessions">sessions</th>
            <th data-col="sess_with_jobs">sess w/jobs</th>
            <th data-col="sess_jobs_pct">sess→jobs %</th>
            <th data-col="sess_with_success">sess w/success</th>
            <th data-col="sess_success_pct">sess→success %</th>
            <th data-col="placements">placements</th>
            <th data-col="sources_missing">sources missing</th>
          </tr>
        </thead>
        <tbody></tbody>
        </table>
      </div>
      </div>

      <div id="singleFiView" style="display:none;"></div>
      </div>
    </section>
  </main>
  </div>

    <script>
      const startDateInput = document.getElementById("startDate");
      const endDateInput = document.getElementById("endDate");
      const dateWarningEl = document.getElementById("dateWarning");
      const fiFilterSelect = document.getElementById("fiFilter");
      const integrationSelect = document.getElementById("integrationFilter");
      const partnerSelect = document.getElementById("partnerFilter");
      const instanceSelect = document.getElementById("instanceFilter");
      const includeTestCheckbox = document.getElementById("includeTestDataCheckbox");
      const applyBtn = document.getElementById("applyBtn");
      const exportCsvBtn = document.getElementById("exportCsvBtn");
      const loaderEl = document.getElementById("pageLoader");
      const loaderTextEl = loaderEl?.querySelector(".loading-text");
      const dateWindowLabel = document.getElementById("dateWindowLabel");
      const bestWindowsDiv = document.getElementById("bestWindows");
      const totalsBar = document.getElementById("totalsBar");
      const partnerSummaryBox = document.getElementById("partnerSummary");
      const quarterSummaryBox = document.createElement("div");
      quarterSummaryBox.id = "quarterSummary";
      quarterSummaryBox.className = "quarter-summary";
      if (partnerSummaryBox?.parentNode) {
        partnerSummaryBox.parentNode.insertBefore(quarterSummaryBox, partnerSummaryBox.nextSibling);
      }
      const multiFiView = document.getElementById("multiFiView");
      const singleFiView = document.getElementById("singleFiView");
      if (includeTestCheckbox) includeTestCheckbox.checked = false;
      let latestDailyDate = null;
      let earliestDailyDate = null;

      const tableBodies = {
        SSO: document.querySelector("#table-SSO tbody"),
        "NON-SSO": document.querySelector("#table-NON-SSO tbody"),
        CardSavr: document.querySelector("#table-CardSavr tbody"),
        TEST: document.querySelector("#table-TEST tbody"),
        UNKNOWN: document.querySelector("#table-UNKNOWN tbody"),
      };
      const groupBlocks = {
        SSO: document.querySelector('[data-group="SSO"]'),
        "NON-SSO": document.querySelector('[data-group="NON-SSO"]'),
        CardSavr: document.querySelector('[data-group="CardSavr"]'),
        TEST: document.querySelector('[data-group="TEST"]'),
        UNKNOWN: document.querySelector('[data-group="UNKNOWN"]'),
      };
      const groupHeaders = Object.fromEntries(
        Object.entries(groupBlocks).map(([key, block]) => [
          key,
          block ? block.querySelector(".group-header") : null,
        ])
      );
      const GROUP_LABELS = {
        SSO: "SSO",
        "NON-SSO": "NON-SSO",
        CardSavr: "CardSavr",
        TEST: "TEST",
        UNKNOWN: "UNKNOWN",
      };
      // Defer heavy work until after paint so the loader can render
      const nextFrame = () => new Promise((resolve) => requestAnimationFrame(resolve));

      const dayMs = 86400000;
      const today = new Date();
      const isoLocalFromDate = (d) => {
        const copy = new Date(d.getTime());
        copy.setHours(0, 0, 0, 0);
        const tzOffset = copy.getTimezoneOffset() * 60000;
        return new Date(copy.getTime() - tzOffset).toISOString().slice(0, 10);
      };
      const isoLocalToday = () => isoLocalFromDate(new Date());
      const isoLocalDaysAgo = (n) => {
        const d = new Date();
        d.setDate(d.getDate() - n);
        return isoLocalFromDate(d);
      };
      const isoLocalYesterday = () => isoLocalDaysAgo(1);
      const defaultEndDateStr = isoLocalYesterday(); // yesterday by default
      const defaultStartDateStr = isoLocalDaysAgo(6); // last 7 days ending yesterday

      const getLatestUsableDateIso = () => {
        // Always allow selection through yesterday, regardless of data availability
        // The date warning will inform users if data isn't ready yet
        return isoLocalYesterday();
      };

      const getMaxSelectableDateIso = () => {
        // Allow selecting through today; raw metadata + warnings handle incomplete data.
        return isoLocalToday();
      };

      function getReferenceDate() {
        const latestIso = getLatestUsableDateIso();
        return new Date(`${latestIso}T00:00:00Z`);
      }

      function enforceEndDateBounds() {
        try {
          const baseIso = getMaxSelectableDateIso();
          if (endDateInput && endDateInput.value && endDateInput.value > baseIso) {
            endDateInput.value = baseIso;
          }
          if (
            startDateInput &&
            endDateInput &&
            startDateInput.value &&
            endDateInput.value &&
            startDateInput.value > endDateInput.value
          ) {
            startDateInput.value = endDateInput.value;
          }
        } catch (err) {
          console.warn("enforceEndDateBounds failed", err);
        }
      }

      function renderDateWarning() {
        if (!dateWarningEl) return;
        try {
          if (!latestDailyDate) {
            dateWarningEl.style.display = "none";
            dateWarningEl.textContent = "";
            return;
          }
          const chosenEnd = endDateInput?.value;
          if (!chosenEnd || chosenEnd <= latestDailyDate) {
            dateWarningEl.style.display = "none";
            dateWarningEl.textContent = "";
            return;
          }
          const linkHref = `maintenance.html?date=${encodeURIComponent(chosenEnd)}`;
          dateWarningEl.innerHTML = `Heads up: data is only available through ${latestDailyDate}. You selected ${chosenEnd}. <a href="${linkHref}">Open maintenance for that date</a>.`;
          dateWarningEl.style.display = "block";
        } catch (err) {
          console.warn("renderDateWarning failed", err);
        }
      }

      function applyPresetRange(value) {
        const ref = getReferenceDate();
        const iso = (d) => d.toISOString().slice(0, 10);
        const daysAgo = (n) => iso(new Date(ref.getTime() - n * dayMs));
        const startOfYear = `${ref.getUTCFullYear()}-01-01`;
        const lastFullQuarterRange = () => {
          const q = Math.floor(ref.getUTCMonth() / 3); // 0-based current quarter
          const endQuarter = q === 0 ? 3 : q; // last full quarter index (1..4)
          const endYear = q === 0 ? ref.getUTCFullYear() - 1 : ref.getUTCFullYear();
          const endMonth = endQuarter * 3; // 3,6,9,12
          const end = new Date(Date.UTC(endYear, endMonth, 0)); // last day of that quarter
          const start = new Date(Date.UTC(endYear, endMonth - 3, 1)); // first day of that quarter
          const start4q = new Date(Date.UTC(start.getUTCFullYear(), start.getUTCMonth() - 9, 1));
          return { start: iso(start4q), end: iso(end) };
        };

        let start = daysAgo(6); // default last 7
        let end = iso(ref);
        switch (value) {
          case "last7":
            start = daysAgo(6);
            break;
          case "last14":
            start = daysAgo(13);
            break;
          case "last30":
            start = daysAgo(29);
            break;
          case "last60":
            start = daysAgo(59);
            break;
          case "last90":
            start = daysAgo(89);
            break;
          case "last4q": {
            const qRange = lastFullQuarterRange();
            start = qRange.start;
            end = qRange.end;
            break;
          }
          case "ytd":
            start = startOfYear;
            break;
          default:
            start = daysAgo(6);
        }
        startDateInput.value = start;
        endDateInput.value = end;
        renderDateWarning();
      }

      function ensureDateDefaults() {
        if (!startDateInput.value) startDateInput.value = defaultStartDateStr;
        if (!endDateInput.value) endDateInput.value = defaultEndDateStr;
        enforceEndDateBounds();
        const preset = document.getElementById("datePreset");
        if (preset && !preset.value) preset.value = "last7";
      }

      function applyDefaultDateRange(force = false) {
        if (force || !startDateInput.value || !endDateInput.value) {
          applyPresetRange("last7");
          const preset = document.getElementById("datePreset");
          if (preset) preset.value = "last7";
        }
      }

      async function safeApplyFilters() {
        ensureDateDefaults();
        enforceEndDateBounds();
        renderDateWarning();
        await applyFilters();
      }

      function updatePartnerOptions(perFi) {
        if (!partnerSelect || !perFi) return;
        const integrationValue = integrationSelect?.value || "(all)";
        const partners = Array.from(
          new Set(
            Object.values(perFi)
              .filter((row) =>
                integrationValue === "(all)" ? true : row.integration_type === integrationValue
              )
              .map((row) => row.partner || "Unknown")
          )
        ).sort((a, b) => a.localeCompare(b));
        const existingValue = partnerSelect.value || PARTNER_ALL_VALUE;
        partnerSelect.innerHTML = "";
        const addOption = (value, label) => {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;
          partnerSelect.appendChild(opt);
        };
        addOption(PARTNER_ALL_VALUE, "(all partners)");
        partners.forEach((partner) => addOption(partner, partner));
        if (existingValue && partners.includes(existingValue)) {
          partnerSelect.value = existingValue;
        } else {
          partnerSelect.value = PARTNER_ALL_VALUE;
        }
      }

      applyDefaultDateRange(true);

const MIN_SELECTS = 10;
const registryInfoMap = new Map();
const registryCardholderMap = new Map();

function buildRegistryLookupKey(fiName, instanceValue) {
  const fiKey = normalizeFiKey(fiName);
  const instKey = normalizeInstanceKey(instanceValue);
  return makeFiInstanceKey(fiKey, instKey);
}

function updateRegistryLookups(registryData = {}) {
  registryInfoMap.clear();
  registryCardholderMap.clear();
  Object.values(registryData || {}).forEach((entry) => {
    if (!entry || typeof entry !== "object") return;
    const fiKey = normalizeFiKey(entry.fi_lookup_key || entry.fi_name);
    const instanceValue = entry.instance || null;
    const comboKey = buildRegistryLookupKey(fiKey, instanceValue);
    if (comboKey && !registryInfoMap.has(comboKey)) {
      registryInfoMap.set(comboKey, entry);
    }
    if (fiKey && !registryInfoMap.has(fiKey)) {
      registryInfoMap.set(fiKey, entry);
    }
    const total = Number(entry.cardholder_total);
    if (!Number.isFinite(total) || total <= 0) return;
    const info = {
      total,
      as_of: entry.cardholder_as_of || null,
      source: entry.cardholder_source || null,
    };
    if (comboKey && !registryCardholderMap.has(comboKey)) {
      registryCardholderMap.set(comboKey, info);
    }
    if (fiKey && !registryCardholderMap.has(fiKey)) {
      registryCardholderMap.set(fiKey, info);
    }
  });
}

function getRegistryEntry(fiName, instanceValue) {
  const fiKey = normalizeFiKey(fiName);
  const comboKey = buildRegistryLookupKey(fiName, instanceValue);
  return (
    registryInfoMap.get(comboKey) ||
    registryInfoMap.get(fiKey) ||
    null
  );
}

function getRegistryCardholderInfo(fiName, instanceValue) {
  const fiKey = normalizeFiKey(fiName);
  const comboKey = buildRegistryLookupKey(fiName, instanceValue);
  return (
    registryCardholderMap.get(comboKey) ||
    registryCardholderMap.get(fiKey) ||
    null
  );
}

function normalizeIntegrationLabel(value) {
  if (!value) return "NON-SSO";
  const raw = value.toString().trim().toUpperCase().replace(/[_\s-]+/g, "-");
  if (raw === "SSO") return "SSO";
  if (raw === "CARDSAVR" || raw === "CARD-SAVR" || raw === "CARDSAVER") {
    return "CardSavr";
  }
  if (raw === "TEST") return "TEST";
  if (raw === "UNKNOWN") return "UNKNOWN";
  return "NON-SSO";
}

function formatPartnerLabel(value) {
  if (!value) return "Unknown";
  return value.toString();
}

const COLUMN_TITLES = {
  highlight: "Name of the highlight window.",
  fi: "Financial institution name.",
  instances: "Cardsavr instance(s) producing this data.",
  integration: "Integration type for the FI (SSO, CardSavr, etc.).",
  dates: "Date range covered by the highlight window.",
  ga_select: "Number of GA select-merchants page views.",
  ga_user: "GA user-data-collection page views.",
  ga_cred: "GA credential-entry page views.",
  reach: "Monthly reach estimate (select views normalized by cardholders).",
  sel_user_pct: "Percent of select views that reached the user data collection step.",
  sel_cred_pct: "Percent of select views that reached the credential entry step.",
  sel_success_pct: "Percent of select views that produced a successful SIS session.",
  sessions: "Total SIS sessions fetched for this FI/instance.",
  sess_with_jobs: "Sessions that contained one or more placement jobs.",
  sess_jobs_pct: "Percent of sessions that contained placement jobs.",
  sess_with_success: "Sessions with at least one successful job.",
  sess_success_pct: "Percent of sessions with a successful job.",
  placements: "Billable placement attempts over the period.",
  sources_missing: "Days where GA or SIS data was missing.",
  period: "Time bucket label for the single-FI view.",
};

function columnAttr(key) {
  const tip = COLUMN_TITLES[key];
  const title = tip ? ` title="${tip}"` : "";
  return ` data-col="${key}"${title}`;
}

function applyColumnTitles(root = document) {
  Object.entries(COLUMN_TITLES).forEach(([key, tip]) => {
    if (!tip) return;
    root.querySelectorAll(`[data-col="${key}"]`).forEach((el) => {
      if (!el.getAttribute("title")) {
        el.setAttribute("title", tip);
      }
    });
  });
}

      const normalizeFiKey = (value) =>
        value ? value.toString().trim().toLowerCase() : "";
      const normalizeInstanceKey = (value) => {
        if (!value) return "unknown";
        const str = value.toString().trim().toLowerCase();
        const normalized = str.replace(/[^a-z0-9]/g, "");
        return normalized || "unknown";
      };
      const makeFiInstanceKey = (fi, instance) =>
        `${normalizeFiKey(fi)}__${normalizeInstanceKey(instance)}`;
      const parseFiInstanceKey = (key = "") => {
        if (!key.includes("__")) {
          return { fi: key, instance: "unknown" };
        }
        const [fi, instance] = key.split("__");
        return { fi, instance: instance || "unknown" };
      };
      const FI_ALL_VALUE = "__all__";
      const PARTNER_ALL_VALUE = "__all_partners__";
      const INSTANCE_ALL_VALUE = "__all_instances__";

      let registryMap = {};
      let dailyFiles = [];
      let dailyData = {};
      let lastAggregated = null;
      let lastRenderContext = null;
      let lastFilterSnapshot = null;
      let latestVisibleRows = [];
      let latestSingleFiBreakdowns = null;
      let latestHighlights = [];
      let latestPartnerSummary = null;
      let latestQuarterSummary = null;
      let lastActiveTab = null;

      function buildLast4QuarterRanges(endIso) {
        const parseIso = (iso) => new Date(`${iso}T00:00:00Z`);
        const endDate = endIso ? parseIso(endIso) : new Date();
        let q = Math.floor(endDate.getUTCMonth() / 3) + 1;
        let year = endDate.getUTCFullYear();
        // use last full quarter
        if (q === Math.floor(new Date().getUTCMonth() / 3) + 1 && endDate.getUTCDate() < 31) {
          // already end of quarter? assume preset ensures full quarter; keep as is
        }
        if (endDate > new Date()) {
          q = Math.floor(new Date().getUTCMonth() / 3);
          year = new Date().getUTCFullYear();
        }
        if (q === Math.floor(new Date().getUTCMonth() / 3) + 1) {
          q = q - 1 || 4;
          if (q === 4) year -= 1;
        }
        const ranges = [];
        for (let i = 0; i < 4; i++) {
          const endMonth = q * 3; // 3,6,9,12
          const end = new Date(Date.UTC(year, endMonth, 0));
          const start = new Date(Date.UTC(year, endMonth - 3, 1));
          ranges.unshift({
            label: `Q${q} ${year}`,
            start: start.toISOString().slice(0, 10),
            end: end.toISOString().slice(0, 10),
          });
          q -= 1;
          if (q === 0) {
            q = 4;
            year -= 1;
          }
        }
        return ranges;
      }

      function summarizeRange(perFi = {}, includeTests = true) {
        const totals = {
          ga_select: 0,
          ga_user: 0,
          ga_cred: 0,
          sessions: 0,
          sess_with_jobs: 0,
          sess_with_success: 0,
          placements: 0,
          cardholders: 0,
        };
        const seenFi = new Set();
        Object.values(perFi || {}).forEach((row) => {
          if (!includeTests && row.is_test) return;
          totals.ga_select += Number(row.ga_select || 0);
          totals.ga_user += Number(row.ga_user || 0);
          totals.ga_cred += Number(row.ga_cred || 0);
          totals.sessions += Number(row.sessions || 0);
          totals.sess_with_jobs += Number(row.sess_with_jobs || 0);
          totals.sess_with_success += Number(row.sess_with_success || 0);
          totals.placements += Number(row.placements || 0);
          const fiKey = row.fi || row.key || "";
          if (!seenFi.has(fiKey) && Number.isFinite(row.cardholders)) {
            totals.cardholders += Number(row.cardholders);
            seenFi.add(fiKey);
          }
        });
        return totals;
      }

      function summarizeQuarterRanges(ranges = [], includeTests = true, cardholderMap) {
        const rows = ranges.map((range) => {
          const perFi = aggregateData(range.start, range.end, cardholderMap);
          const totals = summarizeRange(perFi, includeTests);
          return { ...range, totals };
        });
        const total = rows.reduce(
          (acc, row) => {
            Object.keys(acc).forEach((k) => {
              acc[k] += Number(row.totals[k] || 0);
            });
            return acc;
          },
          {
            ga_select: 0,
            ga_user: 0,
            ga_cred: 0,
            sessions: 0,
            sess_with_jobs: 0,
            sess_with_success: 0,
            placements: 0,
            cardholders: 0,
          }
        );
        return { rows, total };
      }

      function renderQuarterSummary(summary) {
        const box = document.getElementById("quarterSummary");
        if (!box) return;
        if (!summary || !summary.rows || !summary.rows.length) {
          box.style.display = "none";
          box.innerHTML = "";
          return;
        }
        const percent = (num, den) =>
          den && Number.isFinite(num) ? ((num / den) * 100).toFixed(1) + "%" : "—";
        const rowsHtml = summary.rows
          .map((row) => {
            const t = row.totals || {};
            const sessSuccessPct = percent(t.sess_with_success, t.sessions);
            const rangeLabel = row.start === row.end ? row.start : `${row.start} → ${row.end}`;
            return `
              <tr>
                <td>${row.label}</td>
                <td>${rangeLabel}</td>
                <td>${t.ga_select}</td>
                <td>${t.ga_user}</td>
                <td>${t.ga_cred}</td>
                <td>${t.sessions}</td>
                <td>${t.sess_with_success}</td>
                <td>${sessSuccessPct}</td>
                <td>${t.placements}</td>
                <td>${t.cardholders}</td>
              </tr>
            `;
          })
          .join("");
        const total = summary.total || {};
        const totalPct = percent(total.sess_with_success, total.sessions);
        box.innerHTML = `
          <h3>Past 4 quarters</h3>
          <table>
            <thead>
              <tr>
                <th>Quarter</th>
                <th>Dates</th>
                <th>GA select</th>
                <th>GA user</th>
                <th>GA cred</th>
                <th>Sessions</th>
                <th>Sessions w/success</th>
                <th>sess→success %</th>
                <th>Placements</th>
                <th>Cardholders</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
              <tr>
                <th>Total</th>
                <td>4Q aggregate</td>
                <td>${total.ga_select || 0}</td>
                <td>${total.ga_user || 0}</td>
                <td>${total.ga_cred || 0}</td>
                <td>${total.sessions || 0}</td>
                <td>${total.sess_with_success || 0}</td>
                <td>${totalPct}</td>
                <td>${total.placements || 0}</td>
                <td>${total.cardholders || 0}</td>
              </tr>
            </tbody>
          </table>
        `;
        box.style.display = "";
      }

      const tableSortState = {
        multi: {},
        single: {},
      };

      const DEFAULT_SORT = { column: "sessions", direction: "desc" };
      // Initialize date inputs with default window on load
      if (startDateInput && !startDateInput.value) startDateInput.value = defaultStartDateStr;
      if (endDateInput && !endDateInput.value) endDateInput.value = defaultEndDateStr;
      const presetEl = document.getElementById("datePreset");
      if (presetEl) presetEl.value = "last30";

      async function fetchJson(url) {
        const res = await fetch(url);
        if (!res.ok) {
          throw new Error(`${url} → ${res.status}`);
        }
        return res.json();
      }

      function deriveIntegration(meta) {
        const raw = (meta?.integration_type || "").toString().toLowerCase();
        const instances = (meta?.instances || []).map((inst) =>
          (inst || "").toString().toLowerCase()
        );
        const hasOnDot = instances.some((inst) => inst.includes("ondot"));
        if (hasOnDot || raw === "cardsavr") return "CardSavr";
        if (raw === "sso") return "SSO";
        return "NON-SSO";
      }

      function extractInstances(meta) {
        if (!meta || typeof meta !== "object") return [];
        const list = Array.isArray(meta.instances) ? meta.instances.slice() : [];
        if (meta.instance) {
          list.push(meta.instance);
        }
        return Array.from(
          new Set(
            list
              .filter(Boolean)
              .map((inst) => inst.toString())
          )
        ).sort((a, b) => a.localeCompare(b));
      }

      async function fetchRegistry() {
        const data = await fetchJson("/fi-registry");
        const map = {};
        const precedence = { CardSavr: 3, SSO: 2, "NON-SSO": 1 };

        const mergeEntry = (key, payload) => {
          if (!key) return;
          if (!map[key]) {
            map[key] = { ...payload };
            return;
          }
          const existing = map[key];
          const incomingPriority = precedence[payload.integration || "NON-SSO"] || 0;
          const existingPriority = precedence[existing.integration || "NON-SSO"] || 0;
          if (incomingPriority > existingPriority) {
            existing.integration = payload.integration;
          }
          const mergedInstances = new Set(existing.instances || []);
          (payload.instances || []).forEach((inst) => mergedInstances.add(inst));
          existing.instances = Array.from(mergedInstances).sort((a, b) =>
            a.localeCompare(b)
          );
          if (!existing.instance && payload.instance) {
            existing.instance = payload.instance;
          }
          if (!existing.fi_lookup_key && payload.fi_lookup_key) {
            existing.fi_lookup_key = payload.fi_lookup_key;
          }
          if (!existing.fi_name && payload.fi_name) {
            existing.fi_name = payload.fi_name;
          }
          if (!existing.partner && payload.partner) {
            existing.partner = payload.partner;
          }
          const incomingCardholders = Number(payload.cardholder_total);
          if (
            Number.isFinite(incomingCardholders) &&
            incomingCardholders > 0 &&
            (!Number.isFinite(Number(existing.cardholder_total)) ||
              Number(existing.cardholder_total) <= 0)
          ) {
            existing.cardholder_total = payload.cardholder_total;
          }
          if (!existing.cardholder_source && payload.cardholder_source) {
            existing.cardholder_source = payload.cardholder_source;
          }
          if (!existing.cardholder_as_of && payload.cardholder_as_of) {
            existing.cardholder_as_of = payload.cardholder_as_of;
          }
        };

        const assignMeta = (metaLike = {}) => {
          const fiKey = normalizeFiKey(
            metaLike.fi_lookup_key || metaLike.fi_name || metaLike.fi || ""
          );
          if (!fiKey) return;
          const integration = deriveIntegration(metaLike);
          const instances = extractInstances(metaLike);
          const cardholderTotal =
            metaLike.cardholder_total !== undefined
              ? metaLike.cardholder_total
              : null;
          const basePayload = {
            integration,
            instances,
            fi_lookup_key: fiKey,
            fi_name: metaLike.fi_name || metaLike.fi || metaLike.fi_lookup_key || "",
            partner: metaLike.partner || null,
            cardholder_total: cardholderTotal,
            cardholder_as_of: metaLike.cardholder_as_of || null,
            cardholder_source: metaLike.cardholder_source || null,
          };
          mergeEntry(fiKey, {
            ...basePayload,
          });
          if (instances.length) {
            instances.forEach((instance) => {
              const normInstance = normalizeInstanceKey(instance);
              const comboKey = makeFiInstanceKey(fiKey, normInstance);
              mergeEntry(comboKey, {
                ...basePayload,
                instances: [instance],
                instance,
              });
            });
          } else {
            const comboKey = makeFiInstanceKey(fiKey, "unknown");
            mergeEntry(comboKey, {
              ...basePayload,
              instances: ["unknown"],
              instance: "unknown",
            });
          }
        };

        if (Array.isArray(data)) {
          data.forEach((row) => assignMeta(row || {}));
        } else if (data && typeof data === "object") {
          for (const [fiName, meta] of Object.entries(data)) {
            assignMeta({ fi_name: fiName, ...(meta || {}) });
          }
        }

        return map;
      }

      async function fetchDailyList() {
        // Add cache-busting to ensure we always get the latest daily file list
        const payload = await fetch("/list-daily", { cache: 'no-store' }).then(r => r.json());
        return payload.files || [];
      }

      async function fetchDaily(date) {
        // Check cache first (use getAsync for IndexedDB support)
        if (window.DataCache) {
          const cached = await window.DataCache.getAsync(`daily_${date}`);
          if (cached) {
            console.log(`✓ Loaded daily_${date} from cache`);
            return cached;
          }
        }

        // Fetch from server
        console.log(`→ Fetching daily_${date} from server`);
        const payload = await fetchJson(`/daily?date=${date}`);
        const result = payload?.error ? null : payload;

        // Store in cache if valid
        if (result && window.DataCache) {
          await window.DataCache.set(`daily_${date}`, result);
        }

        return result;
      }

      function getCardholderMap() {
        // Cardholders come from fi_registry metadata only now.
        return {};
      }

      function updateInstanceOptions(perFi) {
        if (!instanceSelect) return;
        if (!perFi) return;
        const integrationValue = integrationSelect?.value || "(all)";
        const filterFi = fiFilterSelect?.value || FI_ALL_VALUE;
        const partnerValue = partnerSelect?.value || PARTNER_ALL_VALUE;
        const eligible = Array.from(
          new Set(
            Object.values(perFi)
              .filter((row) =>
                integrationValue === "(all)" ? true : row.integration_type === integrationValue
              )
              .filter((row) =>
                !filterFi || filterFi === FI_ALL_VALUE ? true : row.fi === filterFi
              )
              .filter((row) =>
                partnerValue === PARTNER_ALL_VALUE ? true : (row.partner || "Unknown") === partnerValue
              )
              .flatMap((row) =>
                Array.isArray(row.instances) && row.instances.length
                  ? row.instances
                  : row.instance
                  ? [row.instance]
                  : []
              )
              .map((value) => formatInstanceDisplay(value))
          )
        )
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b));

        const existingValue = instanceSelect.value || INSTANCE_ALL_VALUE;
        instanceSelect.innerHTML = "";

        const addOption = (value, label, selected = false) => {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;
          if (selected) {
            opt.selected = true;
          }
          instanceSelect.appendChild(opt);
        };

        addOption(INSTANCE_ALL_VALUE, "(all instances)", existingValue === INSTANCE_ALL_VALUE);
        eligible.forEach((instance) => {
          addOption(instance, instance, existingValue === instance);
        });

        if (!instanceSelect.value) {
          instanceSelect.value = INSTANCE_ALL_VALUE;
        }
      }

      function updateFiOptions(perFi) {
        if (!perFi || !fiFilterSelect) return;
        const integrationValue = integrationSelect?.value || "(all)";
        const partnerValue = partnerSelect?.value || PARTNER_ALL_VALUE;
        const eligible = Array.from(
          new Set(
            Object.values(perFi)
              .filter((row) =>
                integrationValue === "(all)" ? true : row.integration_type === integrationValue
              )
              .filter((row) =>
                partnerValue === PARTNER_ALL_VALUE ? true : (row.partner || "Unknown") === partnerValue
              )
              .map((row) => row.fi)
          )
        ).sort((a, b) => a.localeCompare(b));

        const existingValue = fiFilterSelect?.value;
        fiFilterSelect.innerHTML = "";
        const addOption = (value, label) => {
          const opt = document.createElement("option");
          opt.value = value;
          opt.textContent = label;
          fiFilterSelect.appendChild(opt);
        };

        addOption(FI_ALL_VALUE, "(all FIs)");
        eligible.forEach((fi) => addOption(fi, fi));

        if (existingValue && existingValue !== FI_ALL_VALUE) {
          const stillPresent = eligible.includes(existingValue);
          fiFilterSelect.value = stillPresent ? existingValue : FI_ALL_VALUE;
        } else {
          fiFilterSelect.value = FI_ALL_VALUE;
        }

        updateInstanceOptions(perFi);
      }

      function getSelectedInstances() {
        if (!instanceSelect) return [];
        const value = instanceSelect.value;
        if (!value || value === INSTANCE_ALL_VALUE) return [];
        return [normalizeInstanceKey(value)];
      }

      const normalizeIntegrationKey = (val) => {
        const upper = (val || "").toString().trim().toUpperCase();
        if (upper === "NON-SSO" || upper === "NON_SSO" || upper === "NONSSO") return "NON-SSO";
        if (upper === "SSO") return "SSO";
        return upper;
      };

      function getVisibleRows(perFi) {
        const shared = window.__FILTER_STATE;
        const includeTests = includeTestCheckbox?.checked;
        const fiTouched = shared && shared.__fiTouched;
        if (shared && shared.page === "funnel") {
          const sharedFiSet = shared.fis
            ? new Set(Array.from(shared.fis).map((fi) => normalizeFiKey(fi)))
            : new Set();
          const partnerFilter =
            shared.partner && shared.partner !== "All" ? shared.partner : "";
          const integrationFilter =
            shared.integration && shared.integration !== "All" ? shared.integration : "";
          return Object.values(perFi).filter((row) => {
            if (!includeTests && row.is_test) return false;
            if (fiTouched && sharedFiSet.size === 0) return false;

            // Check partner filter
            if (partnerFilter) {
              const rowPartner = row.partner || "Unknown";
              if (rowPartner !== partnerFilter) return false;
            }

            // Check integration filter
            if (integrationFilter) {
              const rowIntegration = normalizeIntegrationKey(row.integration_type || "");
              const filterIntegration = normalizeIntegrationKey(integrationFilter);
              if (rowIntegration !== filterIntegration) return false;
            }

            // Check instance filter
            if (shared.instance && shared.instance !== "All") {
              const rowInstanceKey = normalizeInstanceKey(row.instance);
              const filterInstanceKey = normalizeInstanceKey(shared.instance);
              if (rowInstanceKey !== filterInstanceKey) return false;
            }

            // Check FI filter
            if (sharedFiSet.size) {
              const fiKey = normalizeFiKey(row.fi);
              if (!sharedFiSet.has(fiKey)) return false;
            }
            return true;
          });
        }

        const filterFi = fiFilterSelect?.value || FI_ALL_VALUE;
        return Object.values(perFi).filter((row) => {
          if (!includeTests && row.is_test) return false;
          if (filterFi && filterFi !== FI_ALL_VALUE && row.fi !== filterFi) return false;
          return true;
        });
      }

      function isSingleFiSelected() {
        const shared = window.__FILTER_STATE;
        if (shared && shared.page === "funnel") {
          return shared.fis && shared.fis.size === 1;
        }
        return fiFilterSelect && fiFilterSelect.value && fiFilterSelect.value !== FI_ALL_VALUE;
      }

      function parseDateUtc(dateStr) {
        return new Date(`${dateStr}T00:00:00Z`);
      }

      function formatDateUtc(dateObj) {
        return dateObj.toISOString().slice(0, 10);
      }

      function addDaysUtc(dateObj, days) {
        const d = new Date(dateObj);
        d.setUTCDate(d.getUTCDate() + days);
        return d;
      }

      function dayCountInclusive(start, end) {
        if (!start || !end) return null;
        const startDt = parseDateUtc(start);
        const endDt = parseDateUtc(end);
        const diff = Math.floor((endDt - startDt) / (1000 * 60 * 60 * 24));
        return diff >= 0 ? diff + 1 : null;
      }

      function getMonthlyReachValue(row) {
        const cardholders = row?.cardholders;
        if (!cardholders || cardholders <= 0) return 0;
        const dayCount =
          row.dayCount ||
          dayCountInclusive(row.periodStart || row.start, row.periodEnd || row.end) ||
          lastRenderContext?.daySpan ||
          1;
        const reachBase = row.ga_select > 0 ? row.ga_select : row.sessions;
        if (!reachBase || dayCount <= 0) return 0;
        const reachMonthly = reachBase * (30 / dayCount);
        return reachMonthly > 0 ? reachMonthly / cardholders : 0;
      }

      function formatMonthlyReachPct(row) {
        const value = getMonthlyReachValue(row);
        return value > 0 ? (value * 100).toFixed(1) + "%" : "";
      }

      function getSessSuccessRatio(row) {
        if (!row.sessions) return 0;
        return (row.sess_with_success || 0) / row.sessions;
      }

      function getSessJobsRatio(row) {
        if (!row.sessions) return 0;
        return (row.sess_with_jobs || 0) / row.sessions;
      }

      function formatSessSuccessPct(row) {
        if (!row.sessions) return "";
        const ratio = getSessSuccessRatio(row);
        return (ratio * 100).toFixed(1) + "%";
      }

      function formatSessJobsPct(row) {
        if (!row.sessions) return "";
        const ratio = getSessJobsRatio(row);
        return (ratio * 100).toFixed(1) + "%";
      }

      function getSelectToSuccessRatio(row) {
        if (!row) return 0;
        const selectCount =
          typeof row.ga_select === "number" && row.ga_select > 0
            ? row.ga_select
            : typeof row.sel === "number" && row.sel > 0
            ? row.sel
            : typeof row.select === "number" && row.select > 0
            ? row.select
            : 0;
        if (!selectCount) return 0;
        const successSessions =
          typeof row.sess_with_success === "number"
            ? row.sess_with_success
            : typeof row.sessions_with_success === "number"
            ? row.sessions_with_success
            : typeof row.success_sessions === "number"
            ? row.success_sessions
            : 0;
        if (!successSessions) return 0;
        return successSessions / selectCount;
      }

      function formatSelectToSuccessPct(row) {
        const ratio = getSelectToSuccessRatio(row);
        return ratio ? (ratio * 100).toFixed(1) + "%" : "";
      }

      function formatSourcesMissing(sourcesMissing) {
        if (!sourcesMissing || sourcesMissing.length === 0) {
          return "";
        }

        // For multi-FI view: sources_missing is array of objects with {date, missing: []}
        // For single-FI view: sources_missing is array of strings like "2023-07-05: Sess"
        let detailText = "";
        let count = 0;

        if (sourcesMissing.length > 0 && typeof sourcesMissing[0] === "object" && sourcesMissing[0].date) {
          // Multi-FI view format
          detailText = sourcesMissing
            .map((entry) => `${entry.date}: ${entry.missing.join(", ")}`)
            .join("\n");
          count = sourcesMissing.length;
        } else {
          // Single-FI view format (simple array of strings)
          detailText = sourcesMissing.join("\n");
          count = sourcesMissing.length;
        }

        const badge = count === 1 ? "1 gap" : `${count} gaps`;

        return `<div class="sources-missing-tooltip">
          <span class="sources-missing-badge">${badge}</span>
          <div class="tooltip-content">${detailText}</div>
        </div>`;
      }

      function getBillablePlacementCount(placements) {
        if (!placements || typeof placements !== "object") return 0;
        if (typeof placements.successful_placements === "number") {
          return placements.successful_placements;
        }
        if (
          placements.by_termination &&
          typeof placements.by_termination.BILLABLE === "number"
        ) {
          return placements.by_termination.BILLABLE;
        }
        if (typeof placements.total_placements === "number") {
          return placements.total_placements;
        }
        if (typeof placements.total === "number") {
          return placements.total;
        }
        return 0;
      }

      function sanitizeKey(label) {
        return label.toLowerCase().replace(/[^a-z0-9]+/g, "-") || "section";
      }

      const SORT_ACCESSORS = {
        fi: (row) => (row.fi || "").toLowerCase(),
        instances: (row) => (row.instance || (row.instances || []).join(",")).toLowerCase(),
        integration: (row) => (row.integration_type || "").toLowerCase(),
        ga_select: (row) => Number(row.ga_select) || 0,
        ga_user: (row) => Number(row.ga_user) || 0,
        ga_cred: (row) => Number(row.ga_cred) || 0,
        reach: (row) => getMonthlyReachValue(row),
        sel_user_pct: (row) => (row.ga_select ? (row.ga_user || 0) / row.ga_select : 0),
        sel_cred_pct: (row) => (row.ga_select ? (row.ga_cred || 0) / row.ga_select : 0),
        sel_success_pct: (row) => getSelectToSuccessRatio(row),
        sessions: (row) => Number(row.sessions) || 0,
        sess_with_jobs: (row) => Number(row.sess_with_jobs) || 0,
        sess_jobs_pct: (row) => getSessJobsRatio(row),
        sess_with_success: (row) => Number(row.sess_with_success) || 0,
        sess_success_pct: (row) => getSessSuccessRatio(row),
        placements: (row) => Number(row.placements) || 0,
        sources_missing: (row) => (row.sources_missing ? row.sources_missing.length : 0),
        period: (row) => {
          const iso = row.start || row.periodStart || row.period;
          if (iso) return iso.toString().toLowerCase();
          return (row.periodLabel || "").toLowerCase();
        },
      };

      const CSV_COLUMNS = [
        { label: "Section", getter: (row) => row.__section || "" },
        { label: "FI", getter: (row) => row.fi || "" },
        { label: "Partner", getter: (row) => row.partner || "" },
        { label: "Integration", getter: (row) => row.integration_type || "" },
        {
          label: "Instances",
          getter: (row) =>
            row.instance
              ? row.instance
              : Array.isArray(row.instances) && row.instances.length
              ? row.instances.join("; ")
              : "",
        },
        { label: "Period Start", getter: (row) => row.periodStart || row.start || "" },
        { label: "Period End", getter: (row) => row.periodEnd || row.end || "" },
        { label: "GA Select", getter: (row) => row.ga_select || 0 },
        { label: "GA User", getter: (row) => row.ga_user || 0 },
        { label: "GA Cred", getter: (row) => row.ga_cred || 0 },
        {
          label: "Monthly Reach %",
          getter: (row) => formatMonthlyReachPct(row) || "",
        },
        {
          label: "Select→User %",
          getter: (row) =>
            row.ga_select ? (((row.ga_user || 0) / row.ga_select) * 100).toFixed(1) + "%" : "",
        },
        {
          label: "Select→Cred %",
          getter: (row) =>
            row.ga_select ? (((row.ga_cred || 0) / row.ga_select) * 100).toFixed(1) + "%" : "",
        },
        {
          label: "Select→Session Success %",
          getter: (row) => formatSelectToSuccessPct(row) || "",
        },
        { label: "Sessions", getter: (row) => row.sessions || 0 },
        { label: "Sessions w/Jobs", getter: (row) => row.sess_with_jobs || 0 },
        {
          label: "Sessions→Jobs %",
          getter: (row) => formatSessJobsPct(row) || "",
        },
        { label: "Sessions w/Success", getter: (row) => row.sess_with_success || 0 },
        {
          label: "Session Success %",
          getter: (row) => formatSessSuccessPct(row) || "",
        },
        { label: "Placements", getter: (row) => row.placements || 0 },
        {
          label: "Sources Missing",
          getter: (row) => (row.sources_missing || []).join(" | "),
        },
      ];

      function csvEscape(value) {
        if (value === null || value === undefined) return "";
        const str = String(value);
        if (/[",\n]/.test(str)) {
          return `"${str.replace(/"/g, '""')}"`;
        }
        return str;
      }

      function rowToCsvLine(label, row) {
        const rowWithSection = { ...row, __section: label };
        return CSV_COLUMNS.map((col) => csvEscape(col.getter(rowWithSection))).join(",");
      }

      function highlightEntryToRow(entry = {}) {
        const instances = entry.instance ? [entry.instance] : [];
        return {
          fi: entry.fi || "",
          partner: entry.partner || "",
          integration_type: entry.integration || "",
          instances,
          periodStart: entry.start || "",
          periodEnd: entry.end || "",
          ga_select: entry.sel || 0,
          ga_user: entry.user || 0,
          ga_cred: entry.cred || 0,
          sessions: entry.sessions || 0,
          sess_with_jobs: entry.sess_with_jobs || 0,
          sess_with_success: entry.sess_with_success || 0,
          placements: entry.placements || 0,
          sources_missing: entry.sources_missing ? entry.sources_missing.split(" | ") : [],
        };
      }

      function buildTotalsCsvRow(rows, integrationLabel, start, end) {
        const totals = rows.reduce(
          (acc, row) => {
            acc.ga_select += row.ga_select || 0;
            acc.ga_user += row.ga_user || 0;
            acc.ga_cred += row.ga_cred || 0;
            acc.sessions += row.sessions || 0;
            acc.sess_with_jobs += row.sess_with_jobs || 0;
            acc.sess_with_success += row.sess_with_success || 0;
            acc.placements += row.placements || 0;
            acc.cardholders += row.cardholders || 0;
            return acc;
          },
          {
            ga_select: 0,
            ga_user: 0,
            ga_cred: 0,
            sessions: 0,
            sess_with_jobs: 0,
            sess_with_success: 0,
            placements: 0,
            cardholders: 0,
          }
        );
        return {
          fi: "Total",
          partner: rows[0]?.partner || "",
          integration_type: integrationLabel,
          instances: ["—"],
          periodStart: start,
          periodEnd: end,
          ga_select: totals.ga_select,
          ga_user: totals.ga_user,
          ga_cred: totals.ga_cred,
          sessions: totals.sessions,
          sess_with_jobs: totals.sess_with_jobs,
          sess_with_success: totals.sess_with_success,
          placements: totals.placements,
          cardholders: totals.cardholders > 0 ? totals.cardholders : null,
          sources_missing: [],
        };
      }

      function buildCsvDocument({
        summary,
        monthly,
        weekly,
        daily,
        quarterly,
        quarterSummary,
        highlights,
        partnerSummary,
        start,
        end,
      }) {
        const header = CSV_COLUMNS.map((col) => csvEscape(col.label)).join(",");
        const lines = [];
        const title = `Strivve Insights Service Report ${start || ""} → ${end || ""}`.trim();
        lines.push(`"${title}"`, "", "");

        const highlightRows = (highlights || []).filter((h) => h && !h.empty);
        if (highlightRows.length) {
          lines.push("Highlights");
          lines.push(header);
          highlightRows.forEach((entry) => {
            const mapped = highlightEntryToRow(entry);
            lines.push(rowToCsvLine(entry.label || "Highlight", mapped));
          });
          lines.push("", "");
        }

        // Integration buckets (SSO/Non-SSO/etc)
        const summaryRows = summary || [];
        const bucketOrder = ["SSO", "NON-SSO", "CardSavr", "TEST", "UNKNOWN"];
        bucketOrder.forEach((label) => {
          const bucketRows = summaryRows.filter((row) => row.integration_type === label);
          if (!bucketRows.length) return;
          lines.push("", "");
          lines.push(`"${label} Table"`);
          lines.push(header);
          bucketRows.forEach((row) => lines.push(rowToCsvLine(label, row)));
          const totalsRow = buildTotalsCsvRow(bucketRows, label, start, end);
          lines.push(rowToCsvLine(`${label} Total`, totalsRow));
        });

        // Partner integration mix (SSO vs NON-SSO for selected partner)
        if (partnerSummary && partnerSummary.rows && partnerSummary.rows.length) {
          const percentString = (value) =>
            typeof value === "number" && Number.isFinite(value)
              ? value.toFixed(1) + "%"
              : "";
          const partnerHeader = [
            "Integration",
            "FIs",
            "GA Select",
            "Sel→Success %",
            "Sessions",
            "Sessions w/Success",
            "Sessions→Success %",
            "Cardholders",
            "Cardholder Mix %",
            "Monthly Reach %",
          ]
            .map(csvEscape)
            .join(",");
          lines.push("", "");
          lines.push(`${partnerSummary.partner} Integration Mix`);
          lines.push(partnerHeader);
          partnerSummary.rows.forEach((row) => {
            const values = [
              row.integration,
              row.fiCount,
              row.ga_select,
              percentString(row.selSuccessPct),
              row.sessions,
              row.sess_with_success,
              percentString(row.sessionSuccessPct),
              row.cardholders,
              percentString(row.cardholderMixPct),
              percentString(row.reachPct),
            ];
            lines.push(values.map(csvEscape).join(","));
          });
          const totals = partnerSummary.totals || {};
          const totalValues = [
            totals.integration || "Total",
            totals.fiCount || 0,
            totals.ga_select || 0,
            percentString(totals.selSuccessPct),
            totals.sessions || 0,
            totals.sess_with_success || 0,
            percentString(totals.sessionSuccessPct),
            totals.cardholders || 0,
            percentString(totals.cardholderMixPct),
            percentString(totals.reachPct),
          ];
          lines.push(totalValues.map(csvEscape).join(","));
        }

        // Quarterly rollups (multi-FI when last4q)
        if (quarterSummary && quarterSummary.rows && quarterSummary.rows.length) {
          const pct = (n, d) => (d ? ((n / d) * 100).toFixed(1) + "%" : "—");
          lines.push("", "");
          lines.push(`"Quarterly (past 4 quarters)"`);
          lines.push(
            [
              "Quarter",
              "Dates",
              "GA select",
              "GA user",
              "GA cred",
              "Sessions",
              "Sessions w/success",
              "sess→success %",
              "Placements",
              "Cardholders",
            ]
              .map(csvEscape)
              .join(",")
          );
          quarterSummary.rows.forEach((row) => {
            const t = row.totals || {};
            const rangeLabel = row.start === row.end ? row.start : `${row.start} → ${row.end}`;
            lines.push(
              [
                row.label,
                rangeLabel,
                t.ga_select || 0,
                t.ga_user || 0,
                t.ga_cred || 0,
                t.sessions || 0,
                t.sess_with_success || 0,
                pct(t.sess_with_success, t.sessions),
                t.placements || 0,
                t.cardholders || 0,
              ]
                .map(csvEscape)
                .join(",")
            );
          });
          const tot = quarterSummary.total || {};
          lines.push(
            [
              "4Q total",
              "aggregate",
              tot.ga_select || 0,
              tot.ga_user || 0,
              tot.ga_cred || 0,
              tot.sessions || 0,
              tot.sess_with_success || 0,
              ((tot.sess_with_success && tot.sessions)
                ? ((tot.sess_with_success / tot.sessions) * 100).toFixed(1) + "%"
                : "—"),
              tot.placements || 0,
              tot.cardholders || 0,
            ]
              .map(csvEscape)
              .join(",")
          );
        }

        const appendSection = (labelText, rows) => {
          if (!rows || !rows.length) return;
          lines.push("", "");
          lines.push(`"${labelText}"`);
          lines.push(header);
          rows.forEach((row) => lines.push(rowToCsvLine(labelText, row)));
        };

        appendSection("Quarterly Rollups", quarterly);
        appendSection("Monthly Rollups", monthly);
        appendSection("Weekly Rollups", weekly);
        appendSection("Daily Rollups", daily);

        return lines.join("\n");
      }

      function downloadCsv(filename, contents) {
        const blob = new Blob([contents], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 0);
      }

      const CRC_TABLE = (() => {
        const table = new Uint32Array(256);
        for (let i = 0; i < 256; i++) {
          let c = i;
          for (let k = 0; k < 8; k++) {
            c = (c & 1) ? 0xedb88320 ^ (c >>> 1) : c >>> 1;
          }
          table[i] = c >>> 0;
        }
        return table;
      })();

      function crc32(buf) {
        let crc = -1;
        for (let i = 0; i < buf.length; i++) {
          crc = (crc >>> 8) ^ CRC_TABLE[(crc ^ buf[i]) & 0xff];
        }
        return (crc ^ -1) >>> 0;
      }

      function encodeUtf8(str) {
        return new TextEncoder().encode(str);
      }

      function getDosDateTime(date = new Date()) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = Math.floor(date.getSeconds() / 2);
        const dosDate = ((year - 1980) << 9) | (month << 5) | day;
        const dosTime = (hours << 11) | (minutes << 5) | seconds;
        return { dosDate, dosTime };
      }

      function buildZip(files) {
        const parts = [];
        const central = [];
        let offset = 0;
        const { dosDate, dosTime } = getDosDateTime();

        files.forEach(({ name, content }) => {
          const nameBytes = encodeUtf8(name);
          const dataBytes = typeof content === "string" ? encodeUtf8(content) : content;
          const crc = crc32(dataBytes);
          const size = dataBytes.length;

          const localHeader = new Uint8Array(30 + nameBytes.length);
          const view = new DataView(localHeader.buffer);
          view.setUint32(0, 0x04034b50, true);
          view.setUint16(4, 20, true); // version needed
          view.setUint16(6, 0, true); // flags
          view.setUint16(8, 0, true); // compression = 0 (store)
          view.setUint16(10, dosTime, true);
          view.setUint16(12, dosDate, true);
          view.setUint32(14, crc, true);
          view.setUint32(18, size, true);
          view.setUint32(22, size, true);
          view.setUint16(26, nameBytes.length, true);
          view.setUint16(28, 0, true); // extra length
          localHeader.set(nameBytes, 30);

          parts.push(localHeader, dataBytes);

          const centralHeader = new Uint8Array(46 + nameBytes.length);
          const cview = new DataView(centralHeader.buffer);
          cview.setUint32(0, 0x02014b50, true);
          cview.setUint16(4, 0x14, true); // version made by
          cview.setUint16(6, 20, true);
          cview.setUint16(8, 0, true);
          cview.setUint16(10, 0, true);
          cview.setUint16(12, dosTime, true);
          cview.setUint16(14, dosDate, true);
          cview.setUint32(16, crc, true);
          cview.setUint32(20, size, true);
          cview.setUint32(24, size, true);
          cview.setUint16(28, nameBytes.length, true);
          cview.setUint16(30, 0, true);
          cview.setUint16(32, 0, true);
          cview.setUint16(34, 0, true);
          cview.setUint16(36, 0, true);
          cview.setUint32(38, 0, true); // external attrs
          cview.setUint32(42, offset, true);
          centralHeader.set(nameBytes, 46);
          central.push(centralHeader);

          offset += localHeader.length + dataBytes.length;
        });

        const centralSize = central.reduce((sum, entry) => sum + entry.length, 0);
        const centralOffset = offset;
        parts.push(...central);

        const end = new Uint8Array(22);
        const eview = new DataView(end.buffer);
        eview.setUint32(0, 0x06054b50, true);
        eview.setUint16(4, 0, true);
        eview.setUint16(6, 0, true);
        eview.setUint16(8, files.length, true);
        eview.setUint16(10, files.length, true);
        eview.setUint32(12, centralSize, true);
        eview.setUint32(16, centralOffset, true);
        eview.setUint16(20, 0, true);
        parts.push(end);

        const total = parts.reduce((sum, part) => sum + part.length, 0);
        const output = new Uint8Array(total);
        let cursor = 0;
        parts.forEach((part) => {
          output.set(part, cursor);
          cursor += part.length;
        });
        return output;
      }

      function downloadZip(filename, files) {
        const zipData = buildZip(files);
        const blob = new Blob([zipData], { type: "application/zip" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(() => URL.revokeObjectURL(url), 0);
      }

      function getSortState(tableId, scope = "multi") {
        const store = scope === "single" ? tableSortState.single : tableSortState.multi;
        if (!store[tableId]) {
          store[tableId] = scope === "single"
            ? { column: "period", direction: "asc" }
            : { ...DEFAULT_SORT };
        }
        return store[tableId];
      }

      function sortRowsForTable(rows, tableId, scope = "multi") {
        const state = getSortState(tableId, scope);
        const accessor = SORT_ACCESSORS[state.column] || SORT_ACCESSORS.sessions;
        const direction = state.direction === "asc" ? 1 : -1;
        return rows.slice().sort((a, b) => {
          const va = accessor(a);
          const vb = accessor(b);
          if (typeof va === "string" || typeof vb === "string") {
            return va.localeCompare(vb) * direction;
          }
          return (va - vb) * direction;
        });
      }

      function handleSortClick(tableId, column, scope = "multi") {
        const state = getSortState(tableId, scope);
        if (state.column === column) {
          state.direction = state.direction === "asc" ? "desc" : "asc";
        } else {
          state.column = column;
          state.direction = column === "fi" || column === "instances" || column === "integration" || column === "period" ? "asc" : "desc";
        }
        rerenderFromCache();
      }

      function attachSortHandlers(table, tableId, scope = "multi") {
        if (!table || table.dataset.sortHandlerAttached === "true") return;
        table.addEventListener("click", (event) => {
          const th = event.target.closest("th[data-sort-key]");
          if (!th || !table.contains(th)) return;
          event.preventDefault();
          const key = th.dataset.sortKey;
          if (!key) return;
          handleSortClick(tableId, key, scope);
        });
        table.dataset.sortHandlerAttached = "true";
        table.querySelectorAll("th[data-sort-key]").forEach((th) => {
          th.style.cursor = "pointer";
        });
      }
      function dayCountInclusive(start, end) {
        if (!start || !end) return null;
        const startDt = parseDateUtc(start);
        const endDt = parseDateUtc(end);
        const diff = Math.floor((endDt - startDt) / (1000 * 60 * 60 * 24));
        return diff >= 0 ? diff + 1 : null;
      }

      function buildDailyRowsForFi(fiName, startDate, endDate, meta) {
        const norm = normalizeFiKey(fiName);
        const rows = [];
        const dates = Object.keys(dailyData).sort();
        for (const date of dates) {
          if (!inRange(date, startDate, endDate)) continue;
          const day = dailyData[date];
          if (!day?.fi) continue;
          let fiEntry = null;
          for (const [name, data] of Object.entries(day.fi)) {
            if (normalizeFiKey(name) === norm) {
              fiEntry = data;
              break;
            }
          }
          if (!fiEntry) continue;
          const ga = fiEntry.ga || {};
          const sessions = fiEntry.sessions || {};
          const placements = fiEntry.placements || {};
          const missingSources = [];
          if (!day.sources?.ga) missingSources.push(`${date}: GA`);
          if (!day.sources?.sis_sessions) missingSources.push(`${date}: Sess`);
          if (!day.sources?.sis_placements) missingSources.push(`${date}: CPR`);
          rows.push({
            periodLabel: date,
            start: date,
            end: date,
            ga_select: ga.select_merchants || 0,
            ga_user: ga.user_data_collection || 0,
            ga_cred: ga.credential_entry || 0,
            sessions: sessions.total || 0,
            sess_with_jobs: sessions.with_jobs || 0,
            sess_with_success: sessions.with_success || 0,
            placements: getBillablePlacementCount(placements),
            sources_missing: missingSources,
            fi: meta.fi,
            instance: meta.instance,
            instances: meta.instances,
            integration_type: meta.integration,
            partner: meta.partner || "",
            cardholders: meta.cardholders,
            cardholder_source: meta.cardholder_source || null,
            cardholder_as_of: meta.cardholder_as_of || null,
            dayCount: 1,
          });
        }
        return rows;
      }

      function aggregateRowsForPeriod(rows, label, start, end, meta) {
        if (!rows.length) return null;
        const sourcesSet = new Set();
        const agg = {
          periodLabel: label,
          start,
          end,
          ga_select: 0,
          ga_user: 0,
          ga_cred: 0,
          sessions: 0,
          sess_with_jobs: 0,
          sess_with_success: 0,
          placements: 0,
          sources_missing: [],
          fi: meta.fi,
          instance: meta.instance,
          instances: meta.instances,
          integration_type: meta.integration,
          partner: meta.partner || "",
          cardholders: meta.cardholders,
          cardholder_source: meta.cardholder_source || null,
          cardholder_as_of: meta.cardholder_as_of || null,
          dayCount: dayCountInclusive(start, end) || rows.length || 1,
        };

        for (const row of rows) {
          agg.ga_select += row.ga_select || 0;
          agg.ga_user += row.ga_user || 0;
          agg.ga_cred += row.ga_cred || 0;
          agg.sessions += row.sessions || 0;
          agg.sess_with_jobs += row.sess_with_jobs || 0;
          agg.sess_with_success += row.sess_with_success || 0;
          agg.placements += row.placements || 0;
          (row.sources_missing || []).forEach((entry) => sourcesSet.add(entry));
        }
        agg.sources_missing = Array.from(sourcesSet);
        return agg;
      }

      function buildWeeklyRowsForFi(dailyRows, startDate, endDate, meta) {
        const buckets = new Map();
        for (const row of dailyRows) {
          const date = parseDateUtc(row.start);
          const weekStartDate = addDaysUtc(date, -date.getUTCDay());
          const weekEndDate = addDaysUtc(weekStartDate, 6);
          const weekStart = formatDateUtc(weekStartDate);
          const weekEnd = formatDateUtc(weekEndDate);
          if (weekStart < startDate || weekEnd > endDate) continue;
          const key = weekStart;
          if (!buckets.has(key)) {
            buckets.set(key, { start: weekStart, end: weekEnd, rows: [] });
          }
          buckets.get(key).rows.push(row);
        }
        return Array.from(buckets.values())
          .sort((a, b) => a.start.localeCompare(b.start))
          .map((bucket) =>
            aggregateRowsForPeriod(
              bucket.rows,
              `${bucket.start} → ${bucket.end}`,
              bucket.start,
              bucket.end,
              meta
            )
          )
          .filter(Boolean);
      }

      function buildMonthlyRowsForFi(dailyRows, startDate, endDate, meta) {
        const buckets = new Map();
        for (const row of dailyRows) {
          const monthKey = row.start.slice(0, 7);
          const [yearStr, monthStr] = monthKey.split("-");
          const year = Number(yearStr);
          const monthIndex = Number(monthStr) - 1;
          const monthStartDate = new Date(Date.UTC(year, monthIndex, 1));
          const monthEndDate = new Date(Date.UTC(year, monthIndex + 1, 0));
          const monthStart = formatDateUtc(monthStartDate);
          const monthEnd = formatDateUtc(monthEndDate);
          if (monthStart < startDate || monthEnd > endDate) continue;
          if (!buckets.has(monthKey)) {
            buckets.set(monthKey, { start: monthStart, end: monthEnd, rows: [] });
          }
          buckets.get(monthKey).rows.push(row);
        }
        return Array.from(buckets.values())
          .sort((a, b) => a.start.localeCompare(b.start))
          .map((bucket) =>
            aggregateRowsForPeriod(
              bucket.rows,
              `${bucket.start} → ${bucket.end}`,
              bucket.start,
              bucket.end,
              meta
            )
          )
          .filter(Boolean);
      }

      function buildQuarterlyRowsForFi(dailyRows, startDate, endDate, meta) {
        const buckets = new Map();
        for (const row of dailyRows) {
          const date = parseDateUtc(row.start);
          const q = Math.floor(date.getUTCMonth() / 3) + 1;
          const year = date.getUTCFullYear();
          const key = `${year}-Q${q}`;
          const quarterStartDate = new Date(Date.UTC(year, (q - 1) * 3, 1));
          const quarterEndDate = new Date(Date.UTC(year, q * 3, 0));
          const quarterStart = formatDateUtc(quarterStartDate);
          const quarterEnd = formatDateUtc(quarterEndDate);
          // Skip quarter if it's not completely within the date range (same logic as monthly)
          if (quarterStart < startDate || quarterEnd > endDate) continue;
          if (!buckets.has(key)) {
            buckets.set(key, { start: quarterStart, end: quarterEnd, label: `Q${q} ${year}`, rows: [] });
          }
          buckets.get(key).rows.push(row);
        }
        return Array.from(buckets.values())
          .sort((a, b) => a.start.localeCompare(b.start))
          .map((bucket) =>
            aggregateRowsForPeriod(bucket.rows, bucket.label, bucket.start, bucket.end, meta)
          )
          .filter(Boolean);
      }

      let loaderTimer = null;
      let loaderStartedAt = 0;
      const MIN_LOADER_MS = 350;
      const setLoaderMessage = (msg) => {
        if (loaderTextEl && msg) loaderTextEl.textContent = msg;
      };

      function startLoading(message = "Loading data…") {
        if (!loaderEl) return;
        if (loaderTimer) {
          clearTimeout(loaderTimer);
          loaderTimer = null;
        }
        loaderStartedAt = Date.now();
        loaderEl.style.display = "flex";
        loaderEl.style.visibility = "visible";
        loaderEl.style.opacity = "1";
        setLoaderMessage(message);
        if (bestWindowsDiv) bestWindowsDiv.style.opacity = "0.15";
      }

      function stopLoading() {
        if (!loaderEl) return;
        const elapsed = Date.now() - loaderStartedAt;
        if (elapsed < MIN_LOADER_MS) {
          loaderTimer = setTimeout(stopLoading, MIN_LOADER_MS - elapsed);
          return;
        }
        loaderTimer = null;
        loaderEl.style.display = "none";
        loaderEl.style.visibility = "hidden";
        loaderEl.style.opacity = "0";
        if (loaderTextEl) loaderTextEl.textContent = "";
        if (bestWindowsDiv) bestWindowsDiv.style.opacity = "1";
      }

      function inRange(date, start, end) {
        if (!date) return false;
        if (start && date < start) return false;
        if (end && date > end) return false;
        return true;
      }

      const INSTANCE_DISPLAY_OVERRIDES = new Map([
        ["digital-onboarding", "digitalonboarding"],
      ]);

      function formatInstanceDisplay(value) {
        if (!value) return "unknown";
        const base = value.toString().trim().toLowerCase().replace(/[\s_]+/g, "-");
        const display = base || "unknown";
        return INSTANCE_DISPLAY_OVERRIDES.get(display) || display;
      }

      function getFiInstanceEntriesForDay(day) {
        if (day?.fi_instances && Object.keys(day.fi_instances).length) {
          return Object.entries(day.fi_instances).map(([key, row]) => {
            const parsed = parseFiInstanceKey(key);
            const instanceDisplay = formatInstanceDisplay(row.instance || parsed.instance);
            const comboKey = key || makeFiInstanceKey(row.fi_lookup_key || parsed.fi, instanceDisplay);
            return {
              key: comboKey,
              fi: row.fi_lookup_key || parsed.fi,
              instance: instanceDisplay,
              row,
            };
          });
        }
        if (!day?.fi) return [];
        return Object.entries(day.fi).map(([fiName, row]) => {
          const instances = Array.isArray(row.ga_instances) && row.ga_instances.length
            ? row.ga_instances
            : ["unknown"];
          const instanceDisplay = formatInstanceDisplay(instances[0]);
          const comboKey = makeFiInstanceKey(fiName, instanceDisplay);
          return {
            key: comboKey,
            fi: fiName,
            instance: instanceDisplay,
            row,
          };
        });
      }

      function aggregateData(startDate, endDate, cardholderMap) {
        const perFi = {};
        const dates = Object.keys(dailyData).sort();

        for (const date of dates) {
          if (!inRange(date, startDate, endDate)) continue;
          const day = dailyData[date];
          if (!day?.fi) continue;

          const missingSources = [];
          if (!day.sources?.ga) missingSources.push("GA");
          if (!day.sources?.sis_sessions) missingSources.push("Sess");
          if (!day.sources?.sis_placements) missingSources.push("CPR");

          const entries = getFiInstanceEntriesForDay(day);
          for (const entry of entries) {
            const fiName = entry.fi || "unknown_fi";
            const instanceName = entry.instance || "unknown";
            const fiNorm = normalizeFiKey(fiName);
            const comboKey = entry.key || makeFiInstanceKey(fiNorm, instanceName);
            const registryEntry = getRegistryEntry(fiName, instanceName);
            const row = entry.row || {};
            const rowIsTest = Boolean(row.is_test);
            const baseIntegration = normalizeIntegrationLabel(
              registryEntry?.integration || registryEntry?.integration_type
            );
            const integration = rowIsTest ? "TEST" : baseIntegration;
            const partnerLabel = formatPartnerLabel(registryEntry?.partner);
            const agg =
              perFi[comboKey] || {
                key: comboKey,
                fi: fiName,
                instance: instanceName,
                integration_type: integration,
                partner: partnerLabel,
                ga_select: 0,
                ga_user: 0,
                ga_cred: 0,
                sessions: 0,
                sess_with_jobs: 0,
                sess_with_success: 0,
                total_jobs: 0,
                successful_jobs: 0,
                placements: 0,
                sources_missing: [],
                instances: [instanceName],
                is_test: rowIsTest,
                cardholders: null,
                cardholder_source: null,
                cardholder_as_of: null,
              };

            agg.integration_type = integration;
            agg.is_test = agg.is_test || rowIsTest;
            const existingInstanceKey = normalizeInstanceKey(agg.instance);
            const incomingInstanceKey = normalizeInstanceKey(instanceName);
            if (
              agg.instance === "unknown" ||
              (existingInstanceKey === incomingInstanceKey &&
                agg.instance.indexOf("-") === -1 &&
                instanceName.indexOf("-") !== -1)
            ) {
              agg.instance = instanceName;
            }
            const alreadyListed = agg.instances.some(
              (value) => normalizeInstanceKey(value) === incomingInstanceKey
            );
            if (!alreadyListed) {
              agg.instances.push(instanceName);
            }

            if (row.ga) {
              agg.ga_select += row.ga.select_merchants || 0;
              agg.ga_user += row.ga.user_data_collection || 0;
              agg.ga_cred += row.ga.credential_entry || 0;
            }
            if (row.sessions) {
              agg.sessions += row.sessions.total || 0;
              agg.sess_with_jobs += row.sessions.with_jobs || 0;
              agg.sess_with_success += row.sessions.with_success || 0;
              agg.total_jobs += row.sessions.total_jobs || 0;
              agg.successful_jobs += row.sessions.successful_jobs || 0;
            }
            if (row.placements) {
              agg.placements += getBillablePlacementCount(row.placements);
            }
            if (rowIsTest) {
              agg.is_test = true;
            }

            const cardholders = cardholderMap[fiNorm];
            if (typeof cardholders === "number" && cardholders > 0) {
              agg.cardholders = cardholders;
              agg.cardholder_source = "manual";
              agg.cardholder_as_of = null;
            } else {
              const registryInfo = getRegistryCardholderInfo(fiName, instanceName);
              if (registryInfo?.total) {
                agg.cardholders = registryInfo.total;
                agg.cardholder_source = registryInfo.source || null;
                agg.cardholder_as_of = registryInfo.as_of || null;
              }
            }
            if (!agg.partner || agg.partner === "Unknown") {
              agg.partner = partnerLabel;
            }

            if (missingSources.length) {
              agg.sources_missing.push({ date, missing: [...missingSources] });
            }

            perFi[comboKey] = agg;
          }
        }

        for (const agg of Object.values(perFi)) {
          const registryInfo = getRegistryEntry(agg.fi, agg.instance);
          const derivedIntegration =
            registryInfo?.integration || registryInfo?.integration_type || agg.integration_type;
          const instanceKey = normalizeInstanceKey(agg.instance);
          let normalized = agg.is_test ? "TEST" : normalizeIntegrationLabel(derivedIntegration);
          if (instanceKey === "ondot" && normalized !== "TEST") {
            normalized = "CardSavr";
          }
          agg.integration_type = normalized;
        }

        return perFi;
      }

      function computeBestWindows(
        startDate,
        endDate,
        perFiLookup = {},
        visibleRows = [],
        monthlyFactor = 1,
        options = {}
      ) {
        const dates = Object.keys(dailyData)
          .filter((d) => inRange(d, startDate, endDate))
          .sort();
        if (!dates.length) return [];
        const allowLowVolume = Boolean(options.allowLowVolume);

        const allowedSet = new Set(
          visibleRows.map((row) => row.key || makeFiInstanceKey(normalizeFiKey(row.fi), normalizeInstanceKey(row.instance)))
        );
        const restrict = allowedSet.size > 0;
        const dayMissingMap = {};
        const fiDaily = {};
        for (const date of dates) {
          const day = dailyData[date];
          if (!day?.fi) continue;
          const missingSources = [];
          if (!day.sources?.ga) missingSources.push("GA");
          if (!day.sources?.sis_sessions) missingSources.push("Sess");
          if (!day.sources?.sis_placements) missingSources.push("CPR");
          dayMissingMap[date] = missingSources;
          const entries = getFiInstanceEntriesForDay(day);
          for (const entry of entries) {
            const fiDay = entry.row;
            const comboKey = entry.key || makeFiInstanceKey(entry.fi, entry.instance);
            const ga = fiDay.ga || {};
            if (!fiDaily[comboKey]) {
              fiDaily[comboKey] = {};
            }
            fiDaily[comboKey][date] = {
              select: ga.select_merchants || 0,
              user: ga.user_data_collection || 0,
              cred: ga.credential_entry || 0,
              sessions: fiDay.sessions?.total || 0,
              sess_with_jobs: fiDay.sessions?.with_jobs || 0,
              sess_with_success: fiDay.sessions?.with_success || 0,
              placements: getBillablePlacementCount(fiDay.placements),
            };
          }
        }

        const perFiByKey = {};
        Object.entries(perFiLookup || {}).forEach(([key, data]) => {
          perFiByKey[key] = data;
          if (data && data.fi) {
            const combo = data.key || makeFiInstanceKey(data.fi, data.instance);
            if (!perFiByKey[combo]) {
              perFiByKey[combo] = data;
            }
          }
        });

        const defaultCompare = (cand, best) => {
          if (cand.sessionSuccessRatio !== best.sessionSuccessRatio) {
            return cand.sessionSuccessRatio - best.sessionSuccessRatio;
          }
          if (cand.sel !== best.sel) {
            return cand.sel - best.sel;
          }
          return cand.sessions - best.sessions;
        };

        const windows = [
          {
            label: "Most Select Merchant Loads",
            len: 7,
            minSelects: MIN_SELECTS,
            minSessions: 0,
            compare: (cand, best) => {
              if (cand.sel !== best.sel) return cand.sel - best.sel;
              if (cand.sessionSuccessRatio !== best.sessionSuccessRatio) {
                return cand.sessionSuccessRatio - best.sessionSuccessRatio;
              }
              return cand.sessions - best.sessions;
            },
          },
          {
            label: "Most Select Merchant Loads with Successful Placements",
            len: 7,
            minSelects: 25,
            minSessions: 14,
            compare: (cand, best) => {
              if (cand.selSuccessRatio !== best.selSuccessRatio) {
                return cand.selSuccessRatio - best.selSuccessRatio;
              }
              if (cand.sel !== best.sel) return cand.sel - best.sel;
              return cand.sessions - best.sessions;
            },
          },
          {
            label: "Most Total Sessions",
            len: 7,
            minSelects: MIN_SELECTS,
            minSessions: MIN_SELECTS,
            compare: (cand, best) => {
              if (cand.sessions !== best.sessions) return cand.sessions - best.sessions;
              if (cand.sessionSuccessRatio !== best.sessionSuccessRatio) {
                return cand.sessionSuccessRatio - best.sessionSuccessRatio;
              }
              return cand.sel - best.sel;
            },
          },
          {
            label: "Highest Sessions with Success %",
            len: 7,
            minSelects: MIN_SELECTS,
            minSessions: MIN_SELECTS,
            compare: (cand, best) => {
              if (cand.sess_with_success !== best.sess_with_success) {
                return cand.sess_with_success - best.sess_with_success;
              }
              if (cand.sessions !== best.sessions) return cand.sessions - best.sessions;
              return cand.sel - best.sel;
            },
          },
        ];

        const results = [];

        for (const config of windows) {
          const { label, len } = config;
          if (dates.length < len) {
            results.push({ label, empty: true });
            continue;
          }
          const compareFn = typeof config.compare === "function" ? config.compare : defaultCompare;
          const minSelects = allowLowVolume ? 1 : config.minSelects || MIN_SELECTS;
          const minSessions = allowLowVolume ? 1 : config.minSessions || 0;
          let best = null;
          for (const [comboKey, dailyMap] of Object.entries(fiDaily)) {
            if (restrict && !allowedSet.has(comboKey)) continue;
            for (let idx = 0; idx <= dates.length - len; idx += 1) {
              let sel = 0;
              let user = 0;
              let cred = 0;
              let sessions = 0;
              let sessWithJobs = 0;
              let sessWithSuccess = 0;
              let placements = 0;
              const missingEntries = [];
              for (let offset = 0; offset < len; offset += 1) {
                const dayKey = dates[idx + offset];
                const stats = dailyMap[dayKey];
                if (stats) {
                  sel += stats.select || 0;
                  user += stats.user || 0;
                  cred += stats.cred || 0;
                  sessions += stats.sessions || 0;
                  sessWithJobs += stats.sess_with_jobs || 0;
                  sessWithSuccess += stats.sess_with_success || 0;
                  placements += stats.placements || 0;
                }
                const missing = dayMissingMap[dayKey];
                if (missing && missing.length) {
                  missingEntries.push(`${dayKey}: ${missing.join(",")}`);
                }
              }
              if (sel < minSelects) continue;
              if (sessions < minSessions) continue;
              const sessionSuccessRatio = sessions ? sessWithSuccess / sessions : 0;
              const selSuccessRatio = sel ? sessWithSuccess / sel : 0;
              const candidate = {
                label,
                key: comboKey,
                fi: perFiByKey[comboKey]?.fi || comboKey,
                instance: perFiByKey[comboKey]?.instance || parseFiInstanceKey(comboKey).instance,
                start: dates[idx],
                end: dates[idx + len - 1],
                sel,
                user,
                cred,
                conv: sel ? cred / sel : 0,
                successPct: sessionSuccessRatio,
                sessionSuccessRatio,
                selSuccessRatio,
                sessions,
                sess_with_jobs: sessWithJobs,
                sess_with_success: sessWithSuccess,
                placements,
                sources_missing: missingEntries.join(" | "),
              };
              if (!best || compareFn(candidate, best) > 0) {
                best = candidate;
              }
            }
          }
          if (best) {
            const aggRow = perFiByKey[best.key] || {};
            const registryInfo = getRegistryEntry(best.fi, best.instance);
            const registryInstances = registryInfo?.instances || [];
            const instanceList = Array.isArray(aggRow.instances) && aggRow.instances.length
              ? aggRow.instances
              : registryInstances;
            best.instances = instanceList.join(", ") || best.instance || "";
            best.integration = normalizeIntegrationLabel(
              aggRow.integration_type ||
                registryInfo?.integration ||
                registryInfo?.integration_type ||
                "UNKNOWN"
            );
            best.partner = aggRow.partner || registryInfo?.partner || "";
            if (typeof aggRow.cardholders === "number" && aggRow.cardholders > 0) {
              const rowDays = dayCountInclusive(best.start, best.end) || 1;
              const reachBase = best.sel > 0 ? best.sel : best.sessions;
              const reachMonthly = reachBase * (30 / rowDays);
              best.reach = reachMonthly > 0
                ? ((reachMonthly / aggRow.cardholders) * 100).toFixed(1) + "%"
                : "";
            } else {
              best.reach = "";
            }
            best.dayCount = dayCountInclusive(best.start, best.end);
            results.push(best);
          } else {
            results.push({ label, empty: true });
          }
        }

        return results;
      }

      // Termination rules for categorizing placement outcomes
      const TERMINATION_RULES = {
        BILLABLE: { includeInHealth: true, includeInUx: false, severity: "success" },
        SITE_INTERACTION_FAILURE: { includeInHealth: true, includeInUx: false, severity: "site-failure" },
        UNSUCCESSFUL: { includeInHealth: true, includeInUx: false, severity: "site-failure" },
        USER_DATA_FAILURE: { includeInHealth: false, includeInUx: true, severity: "ux" },
        NEVER_STARTED: { includeInHealth: false, includeInUx: true, severity: "ux" },
        TIMEOUT_CREDENTIALS: { includeInHealth: false, includeInUx: true, severity: "ux" },
        TIMEOUT_TFA: { includeInHealth: false, includeInUx: true, severity: "ux" },
        ABANDONED_QUICKSTART: { includeInHealth: false, includeInUx: true, severity: "ux" },
        CANCELED: { includeInHealth: false, includeInUx: true, severity: "ux" },
        ACCOUNT_SETUP_INCOMPLETE: { includeInHealth: false, includeInUx: true, severity: "ux" },
        TOO_MANY_LOGIN_FAILURES: { includeInHealth: false, includeInUx: true, severity: "ux" },
        ACCOUNT_LOCKED: { includeInHealth: false, includeInUx: true, severity: "ux" },
        PASSWORD_RESET_REQUIRED: { includeInHealth: false, includeInUx: true, severity: "ux" },
        INVALID_CARD_DETAILS: { includeInHealth: false, includeInUx: true, severity: "ux" },
        UNKNOWN: { includeInHealth: false, includeInUx: false, severity: "unknown" },
      };

      function calculateConversionMetrics(startDate, endDate, visibleRows) {
        const metrics = {
          totalGaSelect: 0,
          totalSessions: 0,
          sessionsWithoutJobs: 0,
          sessionsWithJobs: 0,
          sessionsWithSuccessfulJobs: 0,
          totalJobs: 0,
          successfulJobs: 0,
          successful: 0,
          systemFailures: 0,
          uxFailures: 0,
          totalPlacements: 0,
          sessionJobCounts: null,
        };

        // Aggregate from visible rows only (respects filters)
        for (const row of visibleRows) {
          metrics.totalGaSelect += row.ga_select || 0;
          metrics.totalSessions += row.sessions || 0;
          metrics.sessionsWithJobs += row.sess_with_jobs || 0;
          metrics.sessionsWithSuccessfulJobs += row.sess_with_success || 0;
          metrics.totalJobs += row.total_jobs || 0;
          metrics.successfulJobs += row.successful_jobs || 0;
        }
        metrics.sessionsWithoutJobs = metrics.totalSessions - metrics.sessionsWithJobs;

        // Build per-session job counts (including zeros) from existing daily rollups, if available.
        try {
          const freq = new Map();
          const datesForJobs = Object.keys(dailyData).sort();
          for (const date of datesForJobs) {
            if (!inRange(date, startDate, endDate)) continue;
            const day = dailyData[date];
            if (!day?.fi_instances) continue;
            for (const fiInstanceKey in day.fi_instances) {
              const fiInstanceData = day.fi_instances[fiInstanceKey];
              const sessions = fiInstanceData?.sessions;
              const jobDist = sessions?.job_distribution;
              if (!jobDist || typeof jobDist !== "object") continue;

              const fiName = fiInstanceData.fi_lookup_key || fiInstanceData.fi_name || "";
              const instanceName = fiInstanceData.instance || "";

              const isVisible = visibleRows.some((row) => {
                const rowFi = normalizeFiKey(row.fi || "");
                const dayFi = normalizeFiKey(fiName);
                if (rowFi !== dayFi) return false;
                const rowInstance = normalizeInstanceKey(row.instance);
                const dayInstance = normalizeInstanceKey(instanceName);
                if (rowInstance && rowInstance !== "any" && dayInstance !== rowInstance) return false;
                return true;
              });
              if (!isVisible) continue;

              for (const [kStr, count] of Object.entries(jobDist)) {
                const k = Number.parseInt(kStr, 10);
                if (!Number.isFinite(k)) continue;
                if (k <= 0) continue;
                const c = Number(count) || 0;
                if (c <= 0) continue;
                freq.set(k, (freq.get(k) || 0) + c);
              }
            }
          }

          const jobCounts = [];
          const zeroCount = Math.max(0, metrics.sessionsWithoutJobs || 0);
          for (let i = 0; i < zeroCount; i++) jobCounts.push(0);
          const keys = Array.from(freq.keys()).sort((a, b) => a - b);
          for (const k of keys) {
            const c = freq.get(k) || 0;
            for (let i = 0; i < c; i++) jobCounts.push(k);
          }
          metrics.sessionJobCounts = jobCounts;

          window.SIS = window.SIS || {};
          window.SIS.funnel = window.SIS.funnel || {};
          window.SIS.funnel.sessionJobCounts = jobCounts;
        } catch (err) {
          // leave null
        }

        // Now categorize placements by termination type
        // Use fi_instances instead of fi to get instance-specific placement data
        const dates = Object.keys(dailyData).sort();
        for (const date of dates) {
          if (!inRange(date, startDate, endDate)) continue;
          const day = dailyData[date];
          if (!day?.fi_instances) continue;

          // Process each FI+instance combination in the day's data
          for (const fiInstanceKey in day.fi_instances) {
            const fiInstanceData = day.fi_instances[fiInstanceKey];
            if (!fiInstanceData?.placements?.by_termination) continue;

            const fiName = fiInstanceData.fi_lookup_key || fiInstanceData.fi_name || "";
            const instanceName = fiInstanceData.instance || "";

            // Check if this FI+instance combination is in the visible rows (filter applied)
            const isVisible = visibleRows.some(row => {
              const rowFi = normalizeFiKey(row.fi || "");
              const dayFi = normalizeFiKey(fiName);
              if (rowFi !== dayFi) return false;

              // Also check instance match
              const rowInstance = normalizeInstanceKey(row.instance);
              const dayInstance = normalizeInstanceKey(instanceName);

              // If the row has a specific instance, make sure it matches
              if (rowInstance && rowInstance !== "any" && dayInstance !== rowInstance) {
                return false;
              }

              return true;
            });

            if (!isVisible) continue;

            // Categorize each termination type
            for (const termType in fiInstanceData.placements.by_termination) {
              const count = fiInstanceData.placements.by_termination[termType];
              const rule = TERMINATION_RULES[termType] || TERMINATION_RULES.UNKNOWN;

              if (rule.severity === "success") {
                metrics.successful += count;
              } else if (rule.includeInHealth) {
                metrics.systemFailures += count;
              } else if (rule.includeInUx) {
                metrics.uxFailures += count;
              } else {
                // Unknown - default to system failures
                metrics.systemFailures += count;
              }
              metrics.totalPlacements += count;
            }
          }
        }

        return metrics;
      }

      function renderConversionAnalysis(metrics) {
        const panel = document.getElementById("conversionAnalysis");
        if (!panel) return;

        const totalGaSelect = metrics.totalGaSelect || 0;
        const totalSessions = metrics.totalSessions || 0;
        const noJobs = metrics.sessionsWithoutJobs || 0;
        const withJobs = metrics.sessionsWithJobs || 0;
        const successfulSessions = metrics.sessionsWithSuccessfulJobs || 0;
        const totalJobs = metrics.totalJobs || 0;
        const totalSuccessfulJobs = metrics.successfulJobs || 0;
        const successful = metrics.successful || 0;
        const systemFail = metrics.systemFailures || 0;
        const uxFail = metrics.uxFailures || 0;
        const totalPlacements = metrics.totalPlacements || 0;

        // Update GA Select metric (Unique CardUpdatr Views)
        document.getElementById("convMetricGaSelect").textContent = totalGaSelect.toLocaleString();

        // Update session metrics
        document.getElementById("convMetricTotalSessions").textContent = totalSessions.toLocaleString();
        document.getElementById("convMetricSessionsPct").textContent = totalGaSelect > 0
          ? `(${((totalSessions / totalGaSelect) * 100).toFixed(1)}%)`
          : "(0.0%)";
        document.getElementById("convMetricNoJobs").textContent = noJobs.toLocaleString();
        document.getElementById("convMetricNoJobsPct").textContent = totalSessions > 0
          ? `(${((noJobs / totalSessions) * 100).toFixed(1)}%)`
          : "(0.0%)";
        document.getElementById("convMetricWithJobs").textContent = withJobs.toLocaleString();
        document.getElementById("convMetricWithJobsPct").textContent = totalSessions > 0
          ? `(${((withJobs / totalSessions) * 100).toFixed(1)}%)`
          : "(0.0%)";

        // Update successful sessions metric
        document.getElementById("convMetricSuccessfulSessions").textContent = successfulSessions.toLocaleString();
        document.getElementById("convMetricSuccessfulSessionsPct").textContent = totalSessions > 0
          ? `(${((successfulSessions / totalSessions) * 100).toFixed(1)}%)`
          : "(0.0%)";

        // Total jobs
        document.getElementById("convMetricTotalJobs").textContent = totalJobs.toLocaleString();

        // Median jobs is computed asynchronously from raw sessions; show placeholder until it resolves.
        const medianEl = document.getElementById("convMetricMedianJobs");
        if (medianEl) medianEl.textContent = "—";
        const avgSuccessfulJobsPerSession = successfulSessions > 0
          ? (totalSuccessfulJobs / successfulSessions).toFixed(2)
          : "0.00";

        document.getElementById("convMetricAvgSuccessfulJobs").textContent = avgSuccessfulJobsPerSession;

        // Update breakdown metrics
        document.getElementById("convBreakdownSuccess").textContent = successful.toLocaleString();
        document.getElementById("convBreakdownSuccessPct").textContent = totalPlacements > 0
          ? `(${((successful / totalPlacements) * 100).toFixed(1)}%)`
          : "(0.0%)";
        document.getElementById("convBreakdownSystem").textContent = systemFail.toLocaleString();
        document.getElementById("convBreakdownSystemPct").textContent = totalPlacements > 0
          ? `(${((systemFail / totalPlacements) * 100).toFixed(1)}%)`
          : "(0.0%)";
        document.getElementById("convBreakdownUX").textContent = uxFail.toLocaleString();
        document.getElementById("convBreakdownUXPct").textContent = totalPlacements > 0
          ? `(${((uxFail / totalPlacements) * 100).toFixed(1)}%)`
          : "(0.0%)";
        document.getElementById("convBreakdownNoJobs").textContent = noJobs.toLocaleString();
        document.getElementById("convBreakdownNoJobsPct").textContent = "";

        // Update progress bars
        if (totalPlacements > 0 || totalSessions > 0) {
          const successPct = totalPlacements > 0 ? (successful / totalPlacements) * 100 : 0;
          const systemPct = totalPlacements > 0 ? (systemFail / totalPlacements) * 100 : 0;
          const uxPct = totalPlacements > 0 ? (uxFail / totalPlacements) * 100 : 0;
          const noJobsPct = totalSessions > 0 ? (noJobs / totalSessions) * 100 : 0;
          document.getElementById("convBarSuccess").style.width = `${successPct}%`;
          document.getElementById("convBarSystem").style.width = `${systemPct}%`;
          document.getElementById("convBarUX").style.width = `${uxPct}%`;
          document.getElementById("convBarNoJobs").style.width = `${noJobsPct}%`;
        } else {
          document.getElementById("convBarSuccess").style.width = "0%";
          document.getElementById("convBarSystem").style.width = "0%";
          document.getElementById("convBarUX").style.width = "0%";
          document.getElementById("convBarNoJobs").style.width = "0%";
        }

        // Show the panel if there's data
        if (totalSessions > 0 || totalPlacements > 0) {
          panel.style.display = "block";
        } else {
          panel.style.display = "none";
        }
      }

      let lastMedianJobsRequestKey = null;

	      async function updateMedianJobsCard(startDate, endDate, visibleRows = []) {
	        const el = document.getElementById("convMetricMedianJobs");
	        if (!el) return;
	        el.removeAttribute("title");
	        const shared = window.__FILTER_STATE;
	        const fis =
	          shared && shared.page === "funnel" && shared.fis && shared.fis.size
	            ? Array.from(shared.fis)
            : [];
        const partner =
          shared && shared.page === "funnel" ? (shared.partner || "") : "";
        const integration =
          shared && shared.page === "funnel"
            ? (shared.integration || "")
            : integrationSelect?.value || "";
        const instance =
          shared && shared.page === "funnel" ? (shared.instance || "") : "";
        const includeTests = includeTestCheckbox?.checked ? "true" : "false";

        const reqKey = [
          startDate,
          endDate,
          includeTests,
          partner,
          integration,
          instance,
          fis.slice().sort().join(","),
        ].join("|");
        lastMedianJobsRequestKey = reqKey;
        el.textContent = "…";

	        const params = new URLSearchParams({
	          start: startDate,
	          end: endDate,
	          includeTests,
	        });

	        const fiInstanceKeys = Array.isArray(visibleRows)
	          ? visibleRows
	              .map((row) => {
	                if (row?.key) return row.key;
	                return makeFiInstanceKey(normalizeFiKey(row?.fi || ""), normalizeInstanceKey(row?.instance));
	              })
	              .filter(Boolean)
	          : [];
	        if (fiInstanceKeys.length) params.set("fiInstances", fiInstanceKeys.join(","));

	        if (partner && partner !== "(all)" && partner !== PARTNER_ALL_VALUE) {
	          params.set("partner", partner);
	        }
	        if (integration && integration !== "(all)") params.set("integration", integration);
	        if (instance && instance !== "(all)" && instance !== INSTANCE_ALL_VALUE) {
	          params.set("instance", instance);
	        }
	        const filteredFis = fis.filter((v) => v && v !== FI_ALL_VALUE);
	        if (filteredFis.length) params.set("fi", filteredFis.join(","));

	        try {
	          const res = await fetch(`/sessions/jobs-stats?${params.toString()}`, {
	            cache: "no-store",
	          });
	          const contentType = (res.headers.get("content-type") || "").toLowerCase();
	          if (!contentType.includes("application/json")) {
	            const preview = await res.text().catch(() => "");
	            throw new Error(
	              `Unexpected response from /sessions/jobs-stats (not JSON). Ensure the SIS server is running on http://localhost:8787 and restart it after updates. Preview: ${preview
	                .toString()
	                .replace(/\s+/g, " ")
	                .slice(0, 140)}`
	            );
	          }
	          const data = await res.json().catch(() => ({}));
	          if (lastMedianJobsRequestKey !== reqKey) return;
	          if (!res.ok) throw new Error(data?.error || `HTTP ${res.status}`);
	          const median = data?.medianJobsPerSessionWithJobs;
	          if (data?.sessionsScanned === 0) {
	            el.textContent = "—";
	            el.title =
	              "No raw sessions were found for this date range. Run Data Refresh so raw session files exist for median calculations.";
	            return;
	          }
	          if (data?.sessionsWithJobs === 0) {
	            el.textContent = "—";
	            el.title = "No sessions with jobs found in this date range.";
	            return;
	          }
	          el.textContent =
	            typeof median === "number" && Number.isFinite(median)
	              ? median.toFixed(median % 1 ? 1 : 0)
	              : "—";
	        } catch (err) {
	          if (lastMedianJobsRequestKey !== reqKey) return;
	          console.warn("median jobs fetch failed", err);
	          el.textContent = "—";
	          el.title =
	            err?.message ||
	            "Unable to load Median Jobs. Ensure the SIS server is running and restart it after updates.";
	        }
	      }

      // Placement Details Cache and Functions
      const placementDetailsCache = new Map();

      /**
       * Initialize placement details event handlers
       */
      function initPlacementDetailsHandlers() {
        const detailsElements = document.querySelectorAll('.placement-details');

        detailsElements.forEach(details => {
          details.addEventListener('toggle', async (event) => {
            if (details.open) {
              await loadPlacementDetails(details);
            }
          });
        });
      }

      /**
       * Fetch and render placement details for a specific breakdown type
       */
      async function loadPlacementDetails(detailsElement) {
        const type = detailsElement.getAttribute('data-type');
        const container = detailsElement.querySelector('.placement-table-container');
        const loadingEl = detailsElement.querySelector('.placement-loading');
        const errorEl = detailsElement.querySelector('.placement-error');

        // Check cache first
        const cacheKey = getCacheKey(type);
        if (placementDetailsCache.has(cacheKey)) {
          renderPlacementTable(container, placementDetailsCache.get(cacheKey), type);
          return;
        }

        // Show loading state
        loadingEl.style.display = 'flex';
        errorEl.style.display = 'none';
        container.innerHTML = '';

        try {
          const data = await fetchPlacementDetails(type);

          // Cache the result
          placementDetailsCache.set(cacheKey, data);

          // Hide loading
          loadingEl.style.display = 'none';

          // Render table
          renderPlacementTable(container, data, type);

        } catch (error) {
          console.error('Failed to load placement details:', error);
          loadingEl.style.display = 'none';
          errorEl.style.display = 'block';
          errorEl.textContent = `Failed to load placements: ${error.message}`;
        }
      }

      /**
       * Generate cache key based on current filters
       */
      function getCacheKey(type) {
        const shared = window.__FILTER_STATE;
        const startDate = startDateInput?.value || defaultStartDateStr;
        const endDate = endDateInput?.value || defaultEndDateStr;
        const fi = fiFilterSelect?.value || '__all__';
        const partner = partnerSelect?.value || '__all_partners__';
        const integration = integrationSelect?.value || '(all)';
        const instance = (shared && shared.instance) || 'All';
        const includeTest = includeTestCheckbox?.checked || false;

        return `${type}|${startDate}|${endDate}|${fi}|${partner}|${integration}|${instance}|${includeTest}`;
      }

      /**
       * Fetch placement details from API
       */
      async function fetchPlacementDetails(type, showAll = false) {
        // Get current filter state from shared filters
        const shared = window.__FILTER_STATE;

        // Build FI list from shared filter state
        let fiParam = '__all__';
        if (shared && shared.page === 'funnel' && shared.fis && shared.fis.size > 0) {
          fiParam = Array.from(shared.fis).join(',');
        } else if (fiFilterSelect?.value && fiFilterSelect.value !== '__all__') {
          fiParam = fiFilterSelect.value;
        }

        // Get partner and integration from shared state or fallback to old selects
        let partnerParam = '__all_partners__';
        if (shared && shared.partner && shared.partner !== 'All') {
          partnerParam = shared.partner;
        } else if (partnerSelect?.value && partnerSelect.value !== '__all_partners__') {
          partnerParam = partnerSelect.value;
        }

        let integrationParam = '(all)';
        if (shared && shared.integration && shared.integration !== 'All') {
          integrationParam = shared.integration;
        } else if (integrationSelect?.value && integrationSelect.value !== '(all)') {
          integrationParam = integrationSelect.value;
        }

        // Get instance from shared state
        let instanceParam = 'All';
        if (shared && shared.instance && shared.instance !== 'All') {
          instanceParam = shared.instance;
        }

        const params = new URLSearchParams({
          type: type,
          startDate: startDateInput?.value || defaultStartDateStr,
          endDate: endDateInput?.value || defaultEndDateStr,
          fi: fiParam,
          partner: partnerParam,
          integration: integrationParam,
          instance: instanceParam,
          includeTest: includeTestCheckbox?.checked ? 'true' : 'false',
          limit: '1000',
          showAll: 'true', // Always show all placements
        });

        const response = await fetch(`/api/placement-details?${params}`);

        if (!response.ok) {
          const error = await response.json().catch(() => ({ error: 'Unknown error' }));
          throw new Error(error.error || `HTTP ${response.status}`);
        }

        return response.json();
      }

      /**
       * Render sessions without jobs, grouped by last page visited
       */
      function renderNoJobsSessions(container, data) {
        const listDiv = document.createElement('div');
        listDiv.className = 'placement-list';

        data.results.forEach(pageGroup => {
          const groupDiv = document.createElement('div');
          groupDiv.className = 'placement-group collapsed';

          // Group header
          const headerDiv = document.createElement('div');
          headerDiv.className = 'placement-group-header';

          // Toggle icon
          const toggleIcon = document.createElement('span');
          toggleIcon.className = 'placement-group-toggle';
          toggleIcon.textContent = '▼';
          headerDiv.appendChild(toggleIcon);

          const pageName = document.createElement('div');
          pageName.className = 'placement-group-merchant';
          pageName.textContent = pageGroup.page;

          const countBadge = document.createElement('div');
          countBadge.className = 'placement-group-count placement-count-system';
          countBadge.textContent = `${pageGroup.count} session${pageGroup.count !== 1 ? 's' : ''}`;

          headerDiv.appendChild(pageName);
          headerDiv.appendChild(countBadge);

          // Add click handler to toggle collapse/expand
          headerDiv.addEventListener('click', () => {
            groupDiv.classList.toggle('collapsed');
          });

          groupDiv.appendChild(headerDiv);

          // Items container
          const itemsDiv = document.createElement('div');
          itemsDiv.className = 'placement-items';

          // Individual session cards
          pageGroup.sessions.forEach(session => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'placement-item';

            const headerRow = document.createElement('div');
            headerRow.className = 'placement-item-header';

            const sessionIdSpan = document.createElement('span');
            sessionIdSpan.className = 'chip chip-id';
            sessionIdSpan.textContent = session.cuid || session.sessionId || 'Unknown';
            sessionIdSpan.title = 'Session CUID';

            const fiSpan = document.createElement('span');
            fiSpan.className = 'chip chip-fi';
            fiSpan.textContent = session.fi;

            const integrationSpan = document.createElement('span');
            integrationSpan.className = 'chip chip-instance';
            integrationSpan.textContent = session.integration;

            const durationSpan = document.createElement('span');
            durationSpan.className = 'chip';
            if (session.durationMs) {
              const seconds = Math.floor(session.durationMs / 1000);
              const minutes = Math.floor(seconds / 60);
              const remainingSeconds = seconds % 60;
              durationSpan.textContent = `Duration: ${minutes}m ${remainingSeconds}s`;
            } else {
              durationSpan.textContent = 'Duration: Unknown';
            }

            // Add session date/time chip
            const dateTimeSpan = document.createElement('span');
            dateTimeSpan.className = 'chip chip-datetime';
            dateTimeSpan.style.marginLeft = 'auto'; // Push to right side
            if (session.createdOn) {
              const dt = new Date(session.createdOn);
              const dateStr = dt.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' });
              const timeStr = dt.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false, timeZoneName: 'short' });
              dateTimeSpan.textContent = `${dateStr} ${timeStr}`;
              dateTimeSpan.title = 'Session Created (Local Time)';
            } else {
              dateTimeSpan.textContent = 'Date: Unknown';
            }

            headerRow.appendChild(sessionIdSpan);
            headerRow.appendChild(fiSpan);
            headerRow.appendChild(integrationSpan);
            headerRow.appendChild(durationSpan);
            headerRow.appendChild(dateTimeSpan);

            itemDiv.appendChild(headerRow);

            // Clickstream summary
            if (session.clickstream && session.clickstream.length > 0) {
              const clickstreamDiv = document.createElement('div');
              clickstreamDiv.className = 'placement-meta';
              clickstreamDiv.innerHTML = `<strong>Clickstream:</strong> ${session.clickstream.map(c => c.url || c.page_title).join(' → ')}`;
              itemDiv.appendChild(clickstreamDiv);
            }

            // Raw session data expandable
            const rawDetails = document.createElement('details');
            rawDetails.className = 'raw-details';

            const rawSummary = document.createElement('summary');
            rawSummary.textContent = 'View raw session data';
            rawDetails.appendChild(rawSummary);

            const rawPre = document.createElement('pre');
            rawPre.className = 'raw-block';
            rawPre.textContent = JSON.stringify(session._rawSession, null, 2);
            rawDetails.appendChild(rawPre);

            itemDiv.appendChild(rawDetails);
            itemsDiv.appendChild(itemDiv);
          });

          groupDiv.appendChild(itemsDiv);
          listDiv.appendChild(groupDiv);
        });

        container.appendChild(listDiv);
      }

      /**
       * Render placement cards with grouped merchants OR sessions without jobs
       */
      function renderPlacementTable(container, data, type) {
        if (!data.results || data.results.length === 0) {
          const emptyMsg = type === 'nojobs' ? 'No sessions without jobs found.' : 'No placements found for this category.';
          container.innerHTML = `<div class="placement-empty">${emptyMsg}</div>`;
          return;
        }

        // Handle "nojobs" type differently
        if (type === 'nojobs') {
          renderNoJobsSessions(container, data);
          return;
        }

        // Create filter section
        const filtersDiv = document.createElement('div');
        filtersDiv.className = 'placement-filters';

        // Build card list
        const listDiv = document.createElement('div');
        listDiv.className = 'placement-list';

        data.results.forEach(merchantGroup => {
          // Create merchant group card
          const groupDiv = document.createElement('div');
          groupDiv.className = 'placement-group collapsed';

          // Group header
          const headerDiv = document.createElement('div');
          headerDiv.className = 'placement-group-header';

          // Toggle icon
          const toggleIcon = document.createElement('span');
          toggleIcon.className = 'placement-group-toggle';
          toggleIcon.textContent = '▼';
          headerDiv.appendChild(toggleIcon);

          const merchantName = document.createElement('div');
          merchantName.className = 'placement-group-merchant';
          merchantName.textContent = merchantGroup.merchant;

          // Create three count badges showing all types
          console.log('[DEBUG] merchantGroup:', merchantGroup.merchant, {
            successCount: merchantGroup.successCount,
            systemCount: merchantGroup.systemCount,
            uxCount: merchantGroup.uxCount
          });

          const successBadge = document.createElement('div');
          successBadge.className = 'placement-group-count placement-count-success';
          const successCount = merchantGroup.successCount || 0;
          successBadge.textContent = `${successCount} success${successCount !== 1 ? 'es' : ''}`;
          successBadge.title = 'Successful placements';
          // Dim if not the active view type
          if (type !== 'success') {
            successBadge.style.opacity = '0.35';
          }

          const systemBadge = document.createElement('div');
          systemBadge.className = 'placement-group-count placement-count-system';
          const systemCount = merchantGroup.systemCount || 0;
          systemBadge.textContent = `${systemCount} system failure${systemCount !== 1 ? 's' : ''}`;
          systemBadge.title = 'System failures';
          // Dim if not the active view type
          if (type !== 'system') {
            systemBadge.style.opacity = '0.35';
          }

          const uxBadge = document.createElement('div');
          uxBadge.className = 'placement-group-count placement-count-ux';
          const uxCount = merchantGroup.uxCount || 0;
          uxBadge.textContent = `${uxCount} UX failure${uxCount !== 1 ? 's' : ''}`;
          uxBadge.title = 'UX failures';
          // Dim if not the active view type
          if (type !== 'ux') {
            uxBadge.style.opacity = '0.35';
          }

          headerDiv.appendChild(merchantName);
          headerDiv.appendChild(successBadge);
          headerDiv.appendChild(systemBadge);
          headerDiv.appendChild(uxBadge);

          // Add click handler to toggle collapse/expand
          headerDiv.addEventListener('click', () => {
            groupDiv.classList.toggle('collapsed');
          });

          groupDiv.appendChild(headerDiv);

          // Items container
          const itemsDiv = document.createElement('div');
          itemsDiv.className = 'placement-items';

          // Individual placement cards
          merchantGroup.placements.forEach((placement, index) => {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'placement-item';

            // Store filter value for filtering
            let filterValue = '';
            if (type === 'system') {
              filterValue = placement.terminationType || '';
            } else if (type === 'ux') {
              filterValue = placement.terminationType || '';
            }
            itemDiv.dataset.filterValue = filterValue;

            // Item header with FI name and badges
            const itemHeaderDiv = document.createElement('div');
            itemHeaderDiv.className = 'placement-item-header';

            // FI chip
            const fiChip = document.createElement('div');
            fiChip.className = 'placement-chip';
            fiChip.textContent = placement.fi;
            itemHeaderDiv.appendChild(fiChip);

            // Status badge
            if (type === 'success') {
              const badge = document.createElement('div');
              badge.className = 'badge success';
              badge.textContent = 'Success';
              itemHeaderDiv.appendChild(badge);
            } else if (type === 'system') {
              const badge = document.createElement('div');
              badge.className = 'badge fail';
              badge.textContent = placement.terminationType || 'System Fail';
              itemHeaderDiv.appendChild(badge);
            } else if (type === 'ux') {
              const badge = document.createElement('div');
              badge.className = 'badge ux';
              badge.textContent = placement.terminationType || 'UX Fail';
              itemHeaderDiv.appendChild(badge);
            }

            // Add date/time chip
            const dateTimeChip = document.createElement('div');
            dateTimeChip.className = 'placement-chip chip-datetime';
            dateTimeChip.style.marginLeft = 'auto'; // Push to right side
            if (placement.createdOn) {
              const dt = new Date(placement.createdOn);
              const dateStr = dt.toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: 'numeric' });
              const timeStr = dt.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false, timeZoneName: 'short' });
              dateTimeChip.textContent = `${dateStr} ${timeStr}`;
              dateTimeChip.title = 'Job Created (Local Time)';
            } else {
              dateTimeChip.textContent = 'Date: Unknown';
            }
            itemHeaderDiv.appendChild(dateTimeChip);

            itemDiv.appendChild(itemHeaderDiv);

            // Metadata
            const metaDiv = document.createElement('div');
            metaDiv.className = 'placement-meta';

            if (type === 'success') {
              if (placement.timeElapsed) {
                const duration = document.createElement('div');
                duration.innerHTML = `<strong>Duration:</strong> ${formatDuration(placement.timeElapsed)}`;
                metaDiv.appendChild(duration);
              }
            } else if (type === 'system') {
              if (placement.statusMessage) {
                const errorMsg = document.createElement('div');
                errorMsg.innerHTML = `<strong>Error:</strong> ${escapeHtml(placement.statusMessage)}`;
                metaDiv.appendChild(errorMsg);
              }
              if (placement.completedOn) {
                const timestamp = document.createElement('div');
                timestamp.innerHTML = `<strong>Timestamp:</strong> ${formatTimestamp(placement.completedOn)}`;
                metaDiv.appendChild(timestamp);
              }
              if (placement.jobId) {
                const jobId = document.createElement('div');
                jobId.innerHTML = `<strong>Job ID:</strong> ${escapeHtml(placement.jobId)}`;
                metaDiv.appendChild(jobId);
              }
            } else if (type === 'ux') {
              if (placement.statusMessage) {
                const errorMsg = document.createElement('div');
                errorMsg.innerHTML = `<strong>Error:</strong> ${escapeHtml(placement.statusMessage)}`;
                metaDiv.appendChild(errorMsg);
              }
            }

            if (metaDiv.children.length > 0) {
              itemDiv.appendChild(metaDiv);
            }

            // Session data details (if available)
            if (placement._session) {
              const sessionDetails = document.createElement('details');
              sessionDetails.className = 'raw-details';

              const sessionSummary = document.createElement('summary');
              sessionSummary.textContent = 'Session Data';
              sessionDetails.appendChild(sessionSummary);

              const sessionBlock = document.createElement('div');
              sessionBlock.className = 'raw-block';
              sessionBlock.innerHTML = syntaxHighlightJson(placement._session);
              sessionDetails.appendChild(sessionBlock);

              itemDiv.appendChild(sessionDetails);
            }

            // Placement raw data details
            const details = document.createElement('details');
            details.className = 'raw-details';

            const summary = document.createElement('summary');
            summary.textContent = 'Placement Data';
            details.appendChild(summary);

            const rawBlock = document.createElement('div');
            rawBlock.className = 'raw-block';
            rawBlock.innerHTML = syntaxHighlightJson(placement._raw || placement);
            details.appendChild(rawBlock);

            itemDiv.appendChild(details);
            itemsDiv.appendChild(itemDiv);
          });

          groupDiv.appendChild(itemsDiv);
          listDiv.appendChild(groupDiv);
        });

        // Clear and populate container
        container.innerHTML = '';
        container.appendChild(filtersDiv);
        container.appendChild(listDiv);

        // Initialize card filters
        initCardFilters(filtersDiv, listDiv, type, data);

        // Show all button removed - we now always show all placements
      }


      /**
       * Format duration in milliseconds to readable string
       */
      function formatDuration(ms) {
        if (!ms || ms === 0) return '-';

        const seconds = Math.floor(ms / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);

        if (hours > 0) {
          return `${hours}h ${minutes % 60}m`;
        } else if (minutes > 0) {
          return `${minutes}m ${seconds % 60}s`;
        } else {
          return `${seconds}s`;
        }
      }

      /**
       * Format ISO timestamp to readable string
       */
      function formatTimestamp(isoString) {
        if (!isoString) return '-';

        const date = new Date(isoString);
        return date.toLocaleString('en-US', {
          month: 'short',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
        });
      }

      /**
       * Escape HTML to prevent XSS
       */
      function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text.toString();
        return div.innerHTML;
      }

      /**
       * Syntax highlight JSON with colors
       */
      function syntaxHighlightJson(obj) {
        const json = JSON.stringify(obj, null, 2);
        return json.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function (match) {
          let cls = 'json-number';
          if (/^"/.test(match)) {
            if (/:$/.test(match)) {
              cls = 'json-key';
            } else {
              cls = 'json-string';
            }
          } else if (/true|false/.test(match)) {
            cls = 'json-boolean';
          } else if (/null/.test(match)) {
            cls = 'json-null';
          }
          return '<span class="' + cls + '">' + escapeHtml(match) + '</span>';
        });
      }

      /**
       * Initialize card filter dropdowns
       */
      function initCardFilters(filtersDiv, listDiv, type, data) {
        // Only add filters for system and ux types
        if (type !== 'system' && type !== 'ux') {
          filtersDiv.style.display = 'none';
          return;
        }

        // Collect unique filter values from placement items
        const uniqueValues = new Set();
        const items = listDiv.querySelectorAll('.placement-item');

        items.forEach(item => {
          const filterValue = item.dataset.filterValue;
          if (filterValue) {
            uniqueValues.add(filterValue);
          }
        });

        // Build filter options
        const valueArray = Array.from(uniqueValues).sort();
        if (valueArray.length === 0) {
          filtersDiv.style.display = 'none';
          return;
        }

        const selectedValues = new Set(valueArray); // All selected by default

        // Create filter row
        const filterRow = document.createElement('div');
        filterRow.className = 'placement-filter-row';

        // Filter label
        const filterLabel = document.createElement('div');
        filterLabel.className = 'placement-filter-label';
        filterLabel.textContent = type === 'system' ? 'Termination Type:' : 'Failure Reason:';
        filterRow.appendChild(filterLabel);

        // Filter wrapper
        const filterWrapper = document.createElement('div');
        filterWrapper.className = 'column-filter-wrapper';

        const filterToggle = document.createElement('div');
        filterToggle.className = 'column-filter-toggle';
        filterToggle.textContent = 'Filter';

        const filterDropdown = document.createElement('div');
        filterDropdown.className = 'column-filter-dropdown';

        // Add controls (Select All / Deselect All)
        const controls = document.createElement('div');
        controls.className = 'column-filter-controls';
        controls.innerHTML = `
          <button class="select-all-btn">Select All</button>
          <button class="deselect-all-btn">Deselect All</button>
        `;
        filterDropdown.appendChild(controls);

        // Add checkboxes for each value
        valueArray.forEach(value => {
          const option = document.createElement('div');
          option.className = 'column-filter-option';

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.checked = true;
          checkbox.id = `filter-${type}-${value.replace(/[^a-z0-9]/gi, '-')}`;

          const label = document.createElement('label');
          label.htmlFor = checkbox.id;
          label.textContent = value;

          option.appendChild(checkbox);
          option.appendChild(label);
          filterDropdown.appendChild(option);

          // Handle checkbox change
          checkbox.addEventListener('change', () => {
            if (checkbox.checked) {
              selectedValues.add(value);
            } else {
              selectedValues.delete(value);
            }
            applyCardFilter();
            updateFilterCount();
          });
        });

        filterWrapper.appendChild(filterToggle);
        filterWrapper.appendChild(filterDropdown);
        filterRow.appendChild(filterWrapper);
        filtersDiv.appendChild(filterRow);

        // Apply filter function
        const applyCardFilter = () => {
          items.forEach(item => {
            const filterValue = item.dataset.filterValue;

            if (filterValue && !selectedValues.has(filterValue)) {
              item.style.display = 'none';
            } else {
              item.style.display = '';
            }
          });

          // Hide placement groups if all items are hidden
          const groups = listDiv.querySelectorAll('.placement-group');
          groups.forEach(group => {
            const groupItems = group.querySelectorAll('.placement-item');
            const allHidden = Array.from(groupItems).every(item => item.style.display === 'none');
            group.style.display = allHidden ? 'none' : '';
          });
        };

        // Update filter count badge
        const updateFilterCount = () => {
          const activeCount = selectedValues.size;
          const totalCount = valueArray.length;

          // Remove existing count badge
          const existingBadge = filterToggle.querySelector('.column-filter-count');
          if (existingBadge) {
            existingBadge.remove();
          }

          // Add count badge if not all selected
          if (activeCount < totalCount) {
            const badge = document.createElement('span');
            badge.className = 'column-filter-count';
            badge.textContent = activeCount;
            filterToggle.appendChild(badge);
          }
        };

        // Toggle dropdown visibility
        filterToggle.addEventListener('click', (e) => {
          e.stopPropagation();
          filterDropdown.classList.toggle('active');
        });

        // Select All button
        controls.querySelector('.select-all-btn').addEventListener('click', () => {
          filterDropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.checked = true;
            const value = cb.labels[0]?.textContent;
            if (value) selectedValues.add(value);
          });
          applyCardFilter();
          updateFilterCount();
        });

        // Deselect All button
        controls.querySelector('.deselect-all-btn').addEventListener('click', () => {
          filterDropdown.querySelectorAll('input[type="checkbox"]').forEach(cb => {
            cb.checked = false;
            const value = cb.labels[0]?.textContent;
            if (value) selectedValues.delete(value);
          });
          applyCardFilter();
          updateFilterCount();
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!filterWrapper.contains(e.target)) {
            filterDropdown.classList.remove('active');
          }
        });
      }

      /**
       * Clear placement details cache when filters change
       */
      function clearPlacementDetailsCache() {
        placementDetailsCache.clear();

        // Close all open details
        const detailsElements = document.querySelectorAll('.placement-details');
        detailsElements.forEach(details => {
          details.open = false;
        });
      }

      function renderBestWindows(entries, visibleRows) {
        bestWindowsDiv.innerHTML = "";
        if (!visibleRows || !visibleRows.length) {
          const emptyDiv = document.createElement("div");
          emptyDiv.className = "muted";
          emptyDiv.textContent = "No highlights because no FIs match the current filters.";
          bestWindowsDiv.appendChild(emptyDiv);
          return;
        }

        if (!entries || !entries.length) {
          const emptyDiv = document.createElement("div");
          emptyDiv.className = "muted";
          emptyDiv.textContent = `No GA highlights with ≥ ${MIN_SELECTS} select views in this window.`;
          bestWindowsDiv.appendChild(emptyDiv);
          return;
        }

        const table = document.createElement("table");
        table.className = "highlights-table";
        table.innerHTML = `
          <thead>
            <tr>
              <th${columnAttr("highlight")}>Highlight</th>
              <th${columnAttr("fi")}>FI</th>
              <th${columnAttr("instances")}>instances</th>
              <th${columnAttr("integration")}>integration</th>
              <th${columnAttr("dates")}>dates</th>
              <th${columnAttr("ga_select")}>GA select</th>
              <th${columnAttr("ga_user")}>GA user</th>
              <th${columnAttr("ga_cred")}>GA cred</th>
              <th${columnAttr("sel_user_pct")}>sel→user %</th>
              <th${columnAttr("sel_cred_pct")}>sel→cred %</th>
              <th${columnAttr("sel_success_pct")}>sel→success %</th>
              <th${columnAttr("sessions")}>sessions</th>
              <th${columnAttr("sess_with_jobs")}>sess w/jobs</th>
              <th${columnAttr("sess_jobs_pct")}>sess→jobs %</th>
              <th${columnAttr("sess_with_success")}>sess w/success</th>
              <th${columnAttr("sess_success_pct")}>sess→success %</th>
              <th${columnAttr("placements")}>placements</th>
            </tr>
          </thead>
        `;

        const tbody = document.createElement("tbody");
        entries.forEach((entry) => {
          const tr = document.createElement("tr");
          if (entry.empty) {
            tr.innerHTML = `
              <td${columnAttr("highlight")}>${entry.label}</td>
              <td colspan="16" class="muted">No data for this highlight window.</td>
            `;
          } else {
            const convPct = entry.conv ? (entry.conv * 100).toFixed(1) + "%" : "0%";
            const selUserPct = entry.sel
              ? ((entry.user || 0) / entry.sel * 100).toFixed(1) + "%"
              : "";
            const selSuccessPct = typeof entry.selSuccessRatio === "number"
              ? (entry.selSuccessRatio * 100).toFixed(1) + "%"
              : formatSelectToSuccessPct({
                  ga_select: entry.sel,
                  sess_with_success: entry.sess_with_success,
                });
            const sessJobsPct =
              entry.sessions && entry.sess_with_jobs
                ? ((entry.sess_with_jobs / entry.sessions) * 100).toFixed(1) + "%"
                : "";
            const sessSuccessPct = typeof entry.sessionSuccessRatio === "number"
              ? (entry.sessionSuccessRatio * 100).toFixed(1) + "%"
              : "";
            const dateRange = entry.start === entry.end ? entry.start : `${entry.start} → ${entry.end}`;
            tr.innerHTML = `
              <td${columnAttr("highlight")}>${entry.label}</td>
              <td${columnAttr("fi")}>${entry.fi}</td>
              <td${columnAttr("instances")}>${entry.instance || ""}</td>
              <td${columnAttr("integration")}>${entry.integration || ""}</td>
              <td${columnAttr("dates")}>${dateRange}</td>
              <td${columnAttr("ga_select")}>${entry.sel}</td>
              <td${columnAttr("ga_user")}>${entry.user || 0}</td>
              <td${columnAttr("ga_cred")}>${entry.cred}</td>
              <td${columnAttr("sel_user_pct")}>${selUserPct}</td>
              <td${columnAttr("sel_cred_pct")}>${convPct}</td>
              <td${columnAttr("sel_success_pct")}>${selSuccessPct}</td>
              <td${columnAttr("sessions")}>${entry.sessions || 0}</td>
              <td${columnAttr("sess_with_jobs")}>${entry.sess_with_jobs || 0}</td>
              <td${columnAttr("sess_jobs_pct")}>${sessJobsPct}</td>
              <td${columnAttr("sess_with_success")}>${entry.sess_with_success || 0}</td>
              <td${columnAttr("sess_success_pct")}>${sessSuccessPct}</td>
              <td${columnAttr("placements")}>${entry.placements || 0}</td>
            `;
          }
          tbody.appendChild(tr);
        });

        table.appendChild(tbody);
        bestWindowsDiv.appendChild(table);
        applyColumnTitles(bestWindowsDiv);
      }

      function buildPartnerSummaryData(rows = [], daySpan = 0, partnerValue = PARTNER_ALL_VALUE) {
        if (!rows || !rows.length || !partnerValue || partnerValue === PARTNER_ALL_VALUE) {
          return null;
        }
        const relevant = rows.filter((row) => (row.partner || "Unknown") === partnerValue);
        if (!relevant.length) {
          return null;
        }
        const makeBucket = () => ({
          fiCount: 0,
          ga_select: 0,
          sessions: 0,
          sess_with_success: 0,
          placements: 0,
          cardholders: 0,
        });
        const buckets = {
          SSO: makeBucket(),
          "NON-SSO": makeBucket(),
        };
        relevant.forEach((row) => {
          const key =
            row.integration_type === "SSO"
              ? "SSO"
              : row.integration_type === "NON-SSO"
              ? "NON-SSO"
              : null;
          if (!key) return;
          const bucket = buckets[key];
          bucket.ga_select += row.ga_select || 0;
          bucket.sessions += row.sessions || 0;
          bucket.sess_with_success += row.sess_with_success || 0;
          bucket.placements += row.placements || 0;
          if (typeof row.cardholders === "number" && row.cardholders > 0) {
            bucket.cardholders += row.cardholders;
          }
          bucket.fiCount += 1;
        });
        const monthlyFactor = daySpan ? 30 / daySpan : 1;
        const totals = makeBucket();
        const bucketSummaries = Object.entries(buckets).map(([key, bucket]) => {
          bucket.monthlySelect = bucket.ga_select * monthlyFactor;
          bucket.selSuccessPct =
            bucket.ga_select > 0 && bucket.sess_with_success > 0
              ? (bucket.sess_with_success / bucket.ga_select) * 100
              : null;
          bucket.sessionSuccessPct =
            bucket.sessions > 0 && bucket.sess_with_success > 0
              ? (bucket.sess_with_success / bucket.sessions) * 100
              : null;
          bucket.reachPct =
            bucket.cardholders > 0 && bucket.monthlySelect > 0
              ? (bucket.monthlySelect / bucket.cardholders) * 100
              : null;
          totals.ga_select += bucket.ga_select;
          totals.sessions += bucket.sessions;
          totals.sess_with_success += bucket.sess_with_success;
          totals.placements += bucket.placements;
          totals.cardholders += bucket.cardholders;
          totals.fiCount += bucket.fiCount;
          return { key, bucket };
        });
        const totalCardholders = totals.cardholders;
        const rowsOut = bucketSummaries.map(({ key, bucket }) => {
          const cardholderMixPct =
            totalCardholders > 0 && bucket.cardholders > 0
              ? (bucket.cardholders / totalCardholders) * 100
              : null;
          return {
            integration: key,
            fiCount: bucket.fiCount,
            ga_select: bucket.ga_select,
            selSuccessPct: bucket.selSuccessPct,
            sessions: bucket.sessions,
            sess_with_success: bucket.sess_with_success,
            sessionSuccessPct: bucket.sessionSuccessPct,
            cardholders: bucket.cardholders,
            cardholderMixPct,
            reachPct: bucket.reachPct,
          };
        });
        totals.monthlySelect = totals.ga_select * monthlyFactor;
        totals.selSuccessPct =
          totals.ga_select > 0 && totals.sess_with_success > 0
            ? (totals.sess_with_success / totals.ga_select) * 100
            : null;
        totals.sessionSuccessPct =
          totals.sessions > 0 && totals.sess_with_success > 0
            ? (totals.sess_with_success / totals.sessions) * 100
            : null;
        totals.cardholderMixPct = totalCardholders > 0 ? 100 : null;
        totals.reachPct =
          totals.cardholders > 0 && totals.monthlySelect > 0
            ? (totals.monthlySelect / totals.cardholders) * 100
            : null;
        return {
          partner: partnerValue,
          daySpan,
          rows: rowsOut,
          totals: {
            integration: "Total",
            fiCount: totals.fiCount,
            ga_select: totals.ga_select,
            selSuccessPct: totals.selSuccessPct,
            sessions: totals.sessions,
            sess_with_success: totals.sess_with_success,
            sessionSuccessPct: totals.sessionSuccessPct,
            cardholders: totals.cardholders,
            cardholderMixPct: totals.cardholderMixPct,
            reachPct: totals.reachPct,
          },
          instanceCount: relevant.length,
        };
      }

      function renderPartnerSummary(summaryData) {
        if (!partnerSummaryBox) return;
        if (!summaryData) {
          partnerSummaryBox.style.display = "none";
          partnerSummaryBox.innerHTML = "";
          return;
        }
        const formatNumber = (value) =>
          typeof value === "number" && !Number.isNaN(value)
            ? value.toLocaleString("en-US")
            : "0";
        const formatCardholders = (value) =>
          typeof value === "number" && value > 0
            ? value.toLocaleString("en-US")
            : "—";
        const formatPercent = (value) =>
          typeof value === "number" && Number.isFinite(value)
            ? value.toFixed(1) + "%"
            : "—";
        const integrationRows = summaryData.rows
          .map(
            (row) => `
            <tr>
              <td>${row.integration}</td>
              <td>${row.fiCount}</td>
              <td>${formatNumber(row.ga_select)}</td>
              <td>${formatPercent(row.selSuccessPct)}</td>
              <td>${formatNumber(row.sessions)}</td>
              <td>${formatNumber(row.sess_with_success)}</td>
              <td>${formatPercent(row.sessionSuccessPct)}</td>
              <td>${formatCardholders(row.cardholders)}</td>
              <td>${formatPercent(row.cardholderMixPct)}</td>
              <td>${formatPercent(row.reachPct)}</td>
            </tr>`
          )
          .join("");
        const totals = summaryData.totals || {};
        partnerSummaryBox.innerHTML = `
          <h3>${summaryData.partner} integration mix</h3>
          <p>Comparing ${summaryData.instanceCount} FI instances over ${summaryData.daySpan || 0}-day window.</p>
          <table class="partner-summary__table">
            <thead>
              <tr>
                <th>Integration</th>
                <th>FIs</th>
                <th>GA select</th>
                <th>Sel→success %</th>
                <th>Sessions</th>
                <th>Sessions w/success</th>
                <th>Sessions→success %</th>
                <th>Cardholders</th>
                <th>Cardholder mix %</th>
                <th>Monthly reach %</th>
              </tr>
            </thead>
            <tbody>
              ${integrationRows}
            </tbody>
            <tfoot>
              <tr>
                <td>Total</td>
                <td>${totals.fiCount || 0}</td>
                <td>${formatNumber(totals.ga_select || 0)}</td>
                <td>${formatPercent(totals.selSuccessPct)}</td>
                <td>${formatNumber(totals.sessions || 0)}</td>
                <td>${formatNumber(totals.sess_with_success || 0)}</td>
                <td>${formatPercent(totals.sessionSuccessPct)}</td>
                <td>${formatCardholders(totals.cardholders || 0)}</td>
                <td>${formatPercent(totals.cardholderMixPct)}</td>
                <td>${formatPercent(totals.reachPct)}</td>
              </tr>
            </tfoot>
          </table>
        `;
        partnerSummaryBox.style.display = "";
      }
      function renderSingleFiSections(visibleRows, startDate, endDate, daySpan) {
        if (!visibleRows || !visibleRows.length) {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "No data available for this FI.";
          singleFiView.appendChild(div);
          latestSingleFiBreakdowns = null;
          return;
        }

        const shared = window.__FILTER_STATE;
        const sharedFi =
          shared && shared.page === "funnel" && shared.fis && shared.fis.size === 1
            ? Array.from(shared.fis)[0]
            : null;
        const fiName =
          (fiFilterSelect && fiFilterSelect.value && fiFilterSelect.value !== FI_ALL_VALUE
            ? fiFilterSelect.value
            : sharedFi) ||
          (visibleRows[0]?.fi || "Unknown FI");
        const perFiRow = visibleRows[0] || {};
        const norm = normalizeFiKey(fiName);
        const instanceDisplay =
          perFiRow.instance || (perFiRow.instances?.[0]) || shared?.instance || "unknown";
        const registryInfo = getRegistryEntry(fiName, instanceDisplay);
        const meta = {
          fi: fiName,
          instance: instanceDisplay,
          instances: [instanceDisplay],
          integration: normalizeIntegrationLabel(
            perFiRow.integration_type ||
              registryInfo?.integration ||
              registryInfo?.integration_type ||
              "UNKNOWN"
          ),
          partner: perFiRow.partner || registryInfo?.partner || "Unknown",
          cardholders: perFiRow.cardholders,
          cardholder_source: perFiRow.cardholder_source || null,
          cardholder_as_of: perFiRow.cardholder_as_of || null,
        };

        const dailyRows = buildDailyRowsForFi(fiName, startDate, endDate, meta);
        const weeklyRows = buildWeeklyRowsForFi(dailyRows, startDate, endDate, meta);
        const monthlyRows = buildMonthlyRowsForFi(dailyRows, startDate, endDate, meta);
        const quarterlyRows = buildQuarterlyRowsForFi(dailyRows, startDate, endDate, meta);
        latestSingleFiBreakdowns = {
          summary: visibleRows,
          daily: dailyRows,
          weekly: weeklyRows,
          monthly: monthlyRows,
          quarterly: quarterlyRows,
        };

        const sections = [];
        sections.push({
          key: "summary",
          title: `Summary (${startDate} → ${endDate})`,
          rows: visibleRows,
        });

        if (quarterlyRows.length) {
          sections.push({
            key: "quarterly",
            title: "Quarterly",
            rows: quarterlyRows,
          });
        }

        if (monthlyRows.length) {
          sections.push({
            key: "monthly",
            title: "Monthly (Full Calendar Months)",
            rows: monthlyRows,
          });
        }

        if (weeklyRows.length) {
          sections.push({
            key: "weekly",
            title: "Weekly (Sunday → Saturday)",
            rows: weeklyRows,
          });
        }

        if (dailyRows.length) {
          sections.push({ key: "daily", title: "Daily", rows: dailyRows });
        }

        const availableSections = sections.filter((section) => section.rows && section.rows.length);
        if (!availableSections.length) {
          const div = document.createElement("div");
          div.className = "muted";
          div.textContent = "No full periods available for this FI within the selected dates.";
          singleFiView.appendChild(div);
          return;
        }

        const tabBar = document.createElement("div");
        tabBar.className = "tab-bar";
        const panelsWrap = document.createElement("div");

        availableSections.forEach((section, idx) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = `tab-button ${idx === 0 ? "active" : ""}`;
          btn.dataset.tab = section.key;
          btn.textContent = section.title;
          tabBar.appendChild(btn);

          const panel = document.createElement("div");
          panel.className = `tab-panel ${idx === 0 ? "active" : ""}`;
          panel.dataset.tab = section.key;
          const heading = document.createElement("h3");
          heading.textContent = section.title;
          panel.appendChild(heading);
          panel.appendChild(createSingleFiTable(section.rows, section.key));
          panelsWrap.appendChild(panel);
        });

        const activateTab = (key) => {
          lastActiveTab = key;
          tabBar.querySelectorAll(".tab-button").forEach((btn) => {
            btn.classList.toggle("active", btn.dataset.tab === key);
          });
          panelsWrap.querySelectorAll(".tab-panel").forEach((panel) => {
            panel.classList.toggle("active", panel.dataset.tab === key);
          });
        };

        tabBar.addEventListener("click", (ev) => {
          const btn = ev.target.closest(".tab-button");
          if (!btn) return;
          activateTab(btn.dataset.tab);
        });

        singleFiView.appendChild(tabBar);
        singleFiView.appendChild(panelsWrap);

        // Restore last active tab if it exists in the available sections, otherwise use first
        const tabToActivate = (lastActiveTab && availableSections.some(s => s.key === lastActiveTab))
          ? lastActiveTab
          : availableSections[0].key;
        activateTab(tabToActivate);
        applyColumnTitles(singleFiView);
      }

      function createSingleFiTable(rows, key) {
        const table = document.createElement("table");
        table.innerHTML = `
          <thead>
            <tr>
              <th data-sort-key="period"${columnAttr("period")}>Period</th>
              <th data-sort-key="fi"${columnAttr("fi")}>FI</th>
              <th data-sort-key="instances"${columnAttr("instances")}>instances</th>
              <th data-sort-key="integration"${columnAttr("integration")}>integration</th>
              <th data-sort-key="ga_select"${columnAttr("ga_select")}>GA select</th>
              <th data-sort-key="ga_user"${columnAttr("ga_user")}>GA user</th>
              <th data-sort-key="ga_cred"${columnAttr("ga_cred")}>GA cred</th>
              <th data-sort-key="reach"${columnAttr("reach")}>monthly reach %</th>
              <th data-sort-key="sel_user_pct"${columnAttr("sel_user_pct")}>sel→user %</th>
              <th data-sort-key="sel_cred_pct"${columnAttr("sel_cred_pct")}>sel→cred %</th>
              <th data-sort-key="sel_success_pct"${columnAttr("sel_success_pct")}>sel→success %</th>
              <th data-sort-key="sessions"${columnAttr("sessions")}>sessions</th>
              <th data-sort-key="sess_with_jobs"${columnAttr("sess_with_jobs")}>sess w/jobs</th>
              <th data-sort-key="sess_jobs_pct"${columnAttr("sess_jobs_pct")}>sess→jobs %</th>
              <th data-sort-key="sess_with_success"${columnAttr("sess_with_success")}>sess w/success</th>
              <th data-sort-key="sess_success_pct"${columnAttr("sess_success_pct")}>sess→success %</th>
              <th data-sort-key="placements"${columnAttr("placements")}>placements</th>
              <th data-sort-key="sources_missing"${columnAttr("sources_missing")}>sources missing</th>
            </tr>
          </thead>
        `;
        const tbody = document.createElement("tbody");
        const tableId = `single-${sanitizeKey(key)}`;
        const sortedRows = sortRowsForTable(rows, tableId, "single");
        sortedRows.forEach((row) => {
          tbody.appendChild(renderSingleFiRow(row));
        });
        table.appendChild(tbody);
        table.id = tableId;
        attachSortHandlers(table, tableId, "single");
        return table;
      }

      function renderSingleFiRow(row) {
        const tr = document.createElement("tr");
        tr.dataset.fi = row.fi || "";
        tr.dataset.partner = row.partner || "Unknown";
        tr.dataset.integration = row.integration_type || "";
        tr.dataset.instance = row.instance || (Array.isArray(row.instances) ? row.instances[0] : "");
        const selUserPct = row.ga_select
          ? ((row.ga_user / row.ga_select) * 100).toFixed(1) + "%"
          : "";
        const selCredPct = row.ga_select
          ? ((row.ga_cred / row.ga_select) * 100).toFixed(1) + "%"
          : "";
        const selSuccessPct = formatSelectToSuccessPct(row);
        const reachPct = formatMonthlyReachPct(row);
        const sessJobsPct = formatSessJobsPct(row);
        const sessSuccessPct = formatSessSuccessPct(row);
        const instancesText = row.instance
          ? row.instance
          : Array.isArray(row.instances) && row.instances.length
          ? row.instances.join(", ")
          : "";
        const missing = formatSourcesMissing(row.sources_missing);
        tr.innerHTML = `
          <td${columnAttr("period")}>${row.periodLabel}</td>
          <td${columnAttr("fi")}>${row.fi}</td>
          <td${columnAttr("instances")}>${instancesText}</td>
          <td${columnAttr("integration")}>${row.integration_type || ""}</td>
          <td${columnAttr("ga_select")}>${row.ga_select}</td>
          <td${columnAttr("ga_user")}>${row.ga_user}</td>
          <td${columnAttr("ga_cred")}>${row.ga_cred}</td>
          <td${columnAttr("reach")}>${reachPct}</td>
          <td${columnAttr("sel_user_pct")}>${selUserPct}</td>
          <td${columnAttr("sel_cred_pct")}>${selCredPct}</td>
          <td${columnAttr("sel_success_pct")}>${selSuccessPct}</td>
          <td${columnAttr("sessions")}>${row.sessions || 0}</td>
          <td${columnAttr("sess_with_jobs")}>${row.sess_with_jobs || 0}</td>
          <td${columnAttr("sess_jobs_pct")}>${sessJobsPct}</td>
          <td${columnAttr("sess_with_success")}>${row.sess_with_success || 0}</td>
          <td${columnAttr("sess_success_pct")}>${sessSuccessPct}</td>
          <td${columnAttr("placements")}>${row.placements || 0}</td>
          <td class="sources-missing"${columnAttr("sources_missing")}>${missing}</td>
        `;
        return tr;
      }

      function renderTables(visibleRows, startDate, endDate, daySpan) {
        latestVisibleRows = visibleRows.slice();
        const monthlyFactor = 30 / Math.max(daySpan || 1, 1);
        visibleRows.forEach((row) => {
          row.periodStart = startDate;
          row.periodEnd = endDate;
          row.dayCount = row.dayCount || daySpan;
        });
        const singleFiMode = isSingleFiSelected();
        const shared = window.__FILTER_STATE;
        const partnerValue =
          shared && shared.page === "funnel"
            ? shared.partner || PARTNER_ALL_VALUE
            : partnerSelect?.value || PARTNER_ALL_VALUE;
        latestPartnerSummary = !singleFiMode
          ? buildPartnerSummaryData(visibleRows, daySpan, partnerValue)
          : null;
        renderPartnerSummary(latestPartnerSummary);

        // Quarter summary when past 4 quarters preset is selected
        const presetVal = document.getElementById("datePreset")?.value || "";
        if (presetVal === "last4q") {
          const ranges = buildLast4QuarterRanges(endDate);
          latestQuarterSummary = summarizeQuarterRanges(ranges, includeTests, cardholderMap);
          renderQuarterSummary(latestQuarterSummary);
        } else {
          latestQuarterSummary = null;
          renderQuarterSummary(null);
        }
        latestSingleFiBreakdowns = null;
        if (singleFiMode) {
          singleFiView.style.display = "";
          multiFiView.style.display = "none";
          singleFiView.innerHTML = "";
          totalsBar.style.display = "none";
          renderSingleFiSections(visibleRows, startDate, endDate, daySpan);
          return;
        }

        singleFiView.style.display = "none";
        singleFiView.innerHTML = "";
        multiFiView.style.display = "";

        Object.values(tableBodies).forEach((tbody) => {
          tbody.innerHTML = "";
        });

        const bucketed = {
          SSO: [],
          "NON-SSO": [],
          CardSavr: [],
          TEST: [],
          UNKNOWN: [],
        };
        visibleRows.forEach((row) => {
            const integration = row.integration_type || "UNKNOWN";
          const normalizedIntegration = normalizeIntegrationLabel(integration);
          row.integration_type = normalizedIntegration;
          const bucketKey = bucketed[normalizedIntegration]
            ? normalizedIntegration
            : "UNKNOWN";
          bucketed[bucketKey].push(row);
        });

        const sumMetrics = (rows) =>
          rows.reduce(
            (acc, row) => {
              acc.ga_select += row.ga_select || 0;
              acc.ga_user += row.ga_user || 0;
              acc.ga_cred += row.ga_cred || 0;
              acc.sessions += row.sessions || 0;
              acc.sess_with_jobs += row.sess_with_jobs || 0;
              acc.sess_with_success += row.sess_with_success || 0;
              acc.placements += row.placements || 0;
              return acc;
            },
            {
              ga_select: 0,
              ga_user: 0,
              ga_cred: 0,
              sessions: 0,
              sess_with_jobs: 0,
              sess_with_success: 0,
              placements: 0,
            }
          );

        const buildTotalsRow = (rows, integration) => {
          if (!rows.length) return null;
          const totals = sumMetrics(rows);
          const selUserPct = totals.ga_select
            ? ((totals.ga_user / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selCredPct = totals.ga_select
            ? ((totals.ga_cred / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selSuccessPct = totals.ga_select
            ? ((totals.sess_with_success / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const sessJobsPct = totals.sessions
            ? ((totals.sess_with_jobs / totals.sessions) * 100).toFixed(1) + "%"
            : "";
          const sessSuccessPct = totals.sessions
            ? ((totals.sess_with_success / totals.sessions) * 100).toFixed(1) + "%"
            : "";
          const reachPct = "";
          const tr = document.createElement("tr");
          tr.className = "totals-row";
          tr.innerHTML = `
            <td${columnAttr("fi")}>Total</td>
            <td${columnAttr("instances")}>—</td>
            <td${columnAttr("integration")}>${integration}</td>
            <td${columnAttr("ga_select")}>${totals.ga_select}</td>
            <td${columnAttr("ga_user")}>${totals.ga_user}</td>
            <td${columnAttr("ga_cred")}>${totals.ga_cred}</td>
            <td${columnAttr("reach")}>${reachPct}</td>
            <td${columnAttr("sel_user_pct")}>${selUserPct}</td>
            <td${columnAttr("sel_cred_pct")}>${selCredPct}</td>
            <td${columnAttr("sel_success_pct")}>${selSuccessPct}</td>
            <td${columnAttr("sessions")}>${totals.sessions}</td>
            <td${columnAttr("sess_with_jobs")}>${totals.sess_with_jobs}</td>
            <td${columnAttr("sess_jobs_pct")}>${sessJobsPct}</td>
            <td${columnAttr("sess_with_success")}>${totals.sess_with_success}</td>
            <td${columnAttr("sess_success_pct")}>${sessSuccessPct}</td>
            <td${columnAttr("placements")}>${totals.placements}</td>
            <td${columnAttr("sources_missing")}></td>
          `;
          return tr;
        };

        const renderRow = (row, integration) => {
          const instancesText = row.instance
            ? row.instance
            : Array.isArray(row.instances) && row.instances.length
            ? row.instances.join(", ")
            : "";
          const selUserPct = row.ga_select
            ? ((row.ga_user / row.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selCredPct = row.ga_select
            ? ((row.ga_cred / row.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selSuccessPct = formatSelectToSuccessPct(row);
          const reachPct = formatMonthlyReachPct(row);
          const sessJobsPct = formatSessJobsPct(row);
          const sessSuccessPct = formatSessSuccessPct(row);

          const missing = formatSourcesMissing(row.sources_missing);

          const tr = document.createElement("tr");
          tr.innerHTML = `
            <td${columnAttr("fi")}>${row.fi}</td>
            <td${columnAttr("instances")}>${instancesText}</td>
            <td${columnAttr("integration")}>${integration}</td>
            <td${columnAttr("ga_select")}>${row.ga_select}</td>
            <td${columnAttr("ga_user")}>${row.ga_user}</td>
            <td${columnAttr("ga_cred")}>${row.ga_cred}</td>
            <td${columnAttr("reach")}>${reachPct}</td>
            <td${columnAttr("sel_user_pct")}>${selUserPct}</td>
            <td${columnAttr("sel_cred_pct")}>${selCredPct}</td>
            <td${columnAttr("sel_success_pct")}>${selSuccessPct}</td>
            <td${columnAttr("sessions")}>${row.sessions}</td>
            <td${columnAttr("sess_with_jobs")}>${row.sess_with_jobs}</td>
            <td${columnAttr("sess_jobs_pct")}>${sessJobsPct}</td>
            <td${columnAttr("sess_with_success")}>${row.sess_with_success}</td>
            <td${columnAttr("sess_success_pct")}>${sessSuccessPct}</td>
            <td${columnAttr("placements")}>${row.placements}</td>
            <td class="sources-missing"${columnAttr("sources_missing")}>${missing}</td>
          `;

          return tr;
        };

        Object.entries(bucketed).forEach(([integration, rows]) => {
          const tbody = tableBodies[integration] || tableBodies.UNKNOWN;
          tbody.innerHTML = "";
          const tableId = `table-${integration}`;
          const sortedRows = sortRowsForTable(rows, tableId, "multi");
          sortedRows.forEach((row) => tbody.appendChild(renderRow(row, integration)));
          const totalsRow = buildTotalsRow(rows, integration);
          if (totalsRow) {
            tbody.appendChild(totalsRow);
          }
          const block = groupBlocks[integration] || groupBlocks.UNKNOWN;
          if (block) {
            block.style.display = rows.length ? "" : "none";
          }
          const headerEl = groupHeaders[integration] || groupHeaders.UNKNOWN;
          if (headerEl) {
            const baseLabel = GROUP_LABELS[integration] || integration;
            headerEl.textContent = rows.length ? `${baseLabel} (${rows.length})` : baseLabel;
          }
          const tableEl = tbody.closest("table");
          attachSortHandlers(tableEl, tableId, "multi");
        });
        applyColumnTitles(multiFiView);

        const visibleCount = visibleRows.length;
        dateWindowLabel.textContent = `Date window: ${startDate} → ${endDate} (${visibleCount} FIs)`;

        if (visibleCount > 1) {
          const totals = sumMetrics(visibleRows);
          const selUserPct = totals.ga_select
            ? ((totals.ga_user / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selCredPct = totals.ga_select
            ? ((totals.ga_cred / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const selSuccessPct = totals.ga_select
            ? ((totals.sess_with_success / totals.ga_select) * 100).toFixed(1) + "%"
            : "";
          const sessJobsPct =
            totals.sessions && totals.sess_with_jobs
              ? ((totals.sess_with_jobs / totals.sessions) * 100).toFixed(1) + "%"
              : "";
          totalsBar.textContent =
            `Totals (${visibleCount} FIs): sel ${totals.ga_select} | user ${totals.ga_user}` +
            ` | cred ${totals.ga_cred} | sel→user ${selUserPct || "—"} | sel→cred ${selCredPct || "—"}` +
            ` | sel→success ${selSuccessPct || "—"}` +
            ` | sessions ${totals.sessions} (jobs ${totals.sess_with_jobs}, success ${totals.sess_with_success})` +
            ` | sess→jobs ${sessJobsPct || "—"} | placements ${totals.placements}`;
          totalsBar.style.display = "block";
        } else {
          totalsBar.style.display = "none";
        }
      }

	      async function applyFilters() {
        // Clear placement details cache when filters change
        clearPlacementDetailsCache();

        await nextFrame(); // allow loader to render before heavy work
        const startDate = startDateInput.value || defaultStartDateStr;
        const endDate = endDateInput.value || defaultEndDateStr;

        // Auto-fetch incomplete raw data if needed
        try {
          const { checkDateRangeForRefetch, autoFetchIncompleteDates } = await import('./assets/js/raw-data-checker.js');
          const applyBtn = document.getElementById('applyBtn');
          const originalText = applyBtn ? applyBtn.textContent : '';
          const originalDisabled = applyBtn ? applyBtn.disabled : false;

          console.log('[FI Funnel] Checking if raw data needs refetch...');
          if (applyBtn) applyBtn.disabled = true;

          try {
            const datesToRefetch = await checkDateRangeForRefetch(startDate, endDate);

            if (datesToRefetch.length > 0) {
              console.log(`[FI Funnel] Auto-fetching ${datesToRefetch.length} incomplete dates`);

              await autoFetchIncompleteDates(datesToRefetch);

              // After fetch completes, reload daily data
              console.log('[FI Funnel] Auto-fetch complete, data will be reprocessed');

              // Refresh in-memory daily data for the dates we refetched so rendering reflects updates.
              try {
                for (const dateStr of datesToRefetch) {
                  const refreshed = await fetchDaily(dateStr);
                  if (refreshed) {
                    dailyData[dateStr] = refreshed;
                  }
                }
              } catch (e) {
                console.warn('[FI Funnel] Failed to refresh daily data after auto-fetch:', e);
              }
            }
          } finally {
            if (applyBtn) {
              applyBtn.disabled = originalDisabled;
              applyBtn.textContent = originalText;
            }
          }

        } catch (err) {
          console.error('[FI Funnel] Auto-fetch check failed:', err);
          // Continue with normal rendering even if auto-fetch fails
        }

        const startDt = new Date(`${startDate}T00:00:00Z`);
        const endDt = new Date(`${endDate}T00:00:00Z`);
        const daySpan = Math.max(1, Math.floor((endDt - startDt) / (1000 * 60 * 60 * 24)) + 1);
        const monthlyFactor = 30 / daySpan;
        const cardholderMap = getCardholderMap();
        const perFi = aggregateData(startDate, endDate, cardholderMap);
        lastAggregated = perFi;
        updatePartnerOptions(perFi);
        updateFiOptions(perFi);
        const visibleRows = getVisibleRows(perFi);
        const singleFiMode = isSingleFiSelected();
        const best = computeBestWindows(startDate, endDate, perFi, visibleRows, monthlyFactor, {
          allowLowVolume: singleFiMode,
        });
        latestHighlights = best;
        renderBestWindows(best, visibleRows);

        // Calculate and render conversion metrics
	        const conversionMetrics = calculateConversionMetrics(startDate, endDate, visibleRows);
	        renderConversionAnalysis(conversionMetrics);
	        updateMedianJobsCard(startDate, endDate, visibleRows);

        renderTables(visibleRows, startDate, endDate, daySpan);

        lastRenderContext = {
          perFi,
          startDate,
          endDate,
          daySpan,
          best,
        };
        // Capture filter snapshot from shared state for accurate comparison
        const shared = window.__FILTER_STATE;
        lastFilterSnapshot = {
          fis: shared && shared.page === "funnel" && shared.fis ? Array.from(shared.fis).sort().join(',') : '',
          instance: shared && shared.page === "funnel" ? (shared.instance || '') : '',
          integration: shared && shared.page === "funnel" ? (shared.integration || '') : (integrationSelect?.value || "(all)"),
          partner: shared && shared.page === "funnel" ? (shared.partner || '') : (partnerSelect?.value || PARTNER_ALL_VALUE),
          includeTest: includeTestCheckbox?.checked || false,
        };
      }

	      function rerenderFromCache() {
        if (!lastRenderContext) return;
        // Compare current filter state with snapshot using shared state
        const shared = window.__FILTER_STATE;
        const currentSnapshot = {
          fis: shared && shared.page === "funnel" && shared.fis ? Array.from(shared.fis).sort().join(',') : '',
          instance: shared && shared.page === "funnel" ? (shared.instance || '') : '',
          integration: shared && shared.page === "funnel" ? (shared.integration || '') : (integrationSelect?.value || "(all)"),
          partner: shared && shared.page === "funnel" ? (shared.partner || '') : (partnerSelect?.value || PARTNER_ALL_VALUE),
          includeTest: includeTestCheckbox?.checked || false,
        };
        const snapshotChanged =
          !lastFilterSnapshot ||
          lastFilterSnapshot.fis !== currentSnapshot.fis ||
          lastFilterSnapshot.instance !== currentSnapshot.instance ||
          lastFilterSnapshot.integration !== currentSnapshot.integration ||
          lastFilterSnapshot.partner !== currentSnapshot.partner ||
          lastFilterSnapshot.includeTest !== currentSnapshot.includeTest;
        if (snapshotChanged) {
          // Clear cache when filters change
          clearPlacementDetailsCache();

          startLoading("Loading data…");
          applyFilters().finally(() => stopLoading());
          return;
        }

        const { perFi, startDate, endDate, daySpan, best } = lastRenderContext;
        const visibleRows = getVisibleRows(perFi);
        renderBestWindows(best, visibleRows);

        // Recalculate and render conversion metrics with new filters
	        const conversionMetrics = calculateConversionMetrics(startDate, endDate, visibleRows);
	        renderConversionAnalysis(conversionMetrics);
	        updateMedianJobsCard(startDate, endDate, visibleRows);

	        renderTables(visibleRows, startDate, endDate, daySpan);
	      }

      async function init() {
        try {
          startLoading("Loading funnel data…");
          try {
            registryMap = await fetchRegistry();
            updateRegistryLookups(registryMap);
          } catch (err) {
            console.error("Failed to load fi_registry:", err);
            registryMap = {};
          }

          try {
            const fetched = await fetchDailyList();
            dailyFiles = Array.isArray(fetched) ? fetched : [];
            if (dailyFiles.length) {
              const sortedDates = dailyFiles
                .map((file) => file.replace(".json", ""))
                .filter((d) => /^\d{4}-\d{2}-\d{2}$/.test(d))
                .sort();
              earliestDailyDate = sortedDates[0] || null;
              latestDailyDate = sortedDates[sortedDates.length - 1] || null;
              const baseIso = getMaxSelectableDateIso();
              if (endDateInput && (!endDateInput.value || endDateInput.value > baseIso)) {
                endDateInput.value = baseIso;
              }
              if (startDateInput && startDateInput.value > (endDateInput?.value || baseIso)) {
                startDateInput.value = endDateInput.value || baseIso;
              }
              renderDateWarning();
            }

            // Try to load all data from bulk cache first (using async getAsync for IndexedDB)
            // Include data version in cache key so it invalidates when files are added/removed
            const dataVersion = window.DataCache?.currentVersion || 'unknown';
            const bulkCacheKey = `funnel_all_daily_data_v${dataVersion}`;
            if (window.DataCache) {
              console.log(`🔍 Checking bulk cache (version ${dataVersion})...`);
              const cachedBulk = await window.DataCache.getAsync(bulkCacheKey);
              console.log('Bulk cache result:', cachedBulk ? `Found ${Object.keys(cachedBulk).length} days` : 'Not found');

              if (cachedBulk && typeof cachedBulk === 'object' && Object.keys(cachedBulk).length > 0) {
                setLoaderMessage('✓ Loading from cache…');
                dailyData = cachedBulk;
                console.log(`✓ Loaded ${Object.keys(dailyData).length} days from bulk cache`);
              } else {
                // No bulk cache, load individually
                console.log('→ Bulk cache empty, loading from server...');
                const totalDays = dailyFiles.length;
                let loadedDays = 0;
                for (const file of dailyFiles) {
                  const date = file.replace(".json", "");
                  setLoaderMessage(`Loading daily data… ${loadedDays}/${totalDays}`);
                  const data = await fetchDaily(date);
                  if (data) {
                    dailyData[date] = data;
                  }
                  loadedDays += 1;
                }
                if (totalDays) {
                  setLoaderMessage(`Loading daily data… ${totalDays}/${totalDays}`);
                }

                // Store bulk cache for next time (using async set for IndexedDB)
                if (Object.keys(dailyData).length > 0) {
                  console.log(`💾 Saving ${Object.keys(dailyData).length} days to bulk cache...`);
                  // Fire-and-forget: do not block rendering on bulk cache writes.
                  window.DataCache.set(bulkCacheKey, dailyData).then((saved) => {
                    if (saved) {
                      console.log(`✓ Successfully cached ${Object.keys(dailyData).length} days in bulk cache`);
                    } else {
                      console.warn('⚠ Failed to save bulk cache');
                    }
                  }).catch((err) => {
                    console.warn('⚠ Failed to save bulk cache:', err);
                  });
                }
              }
            } else {
              // No DataCache available, load normally
              const totalDays = dailyFiles.length;
              let loadedDays = 0;
              for (const file of dailyFiles) {
                const date = file.replace(".json", "");
                setLoaderMessage(`Loading daily data… ${loadedDays}/${totalDays}`);
                const data = await fetchDaily(date);
                if (data) {
                  dailyData[date] = data;
                }
                loadedDays += 1;
              }
              if (totalDays) {
                setLoaderMessage(`Loading daily data… ${totalDays}/${totalDays}`);
              }
            }
          } catch (err) {
            console.error("Failed to load daily data:", err);
          }

          // Initialize placement details handlers
          initPlacementDetailsHandlers();

          await safeApplyFilters();
        } catch (err) {
          console.error("Init failed", err);
          stopLoading();
        } finally {
          stopLoading();
        }
      }

      applyBtn.addEventListener("click", () => {
        // Force a full recompute for new date ranges
        lastRenderContext = null;
        lastFilterSnapshot = null;
        startLoading("Loading data…");
        safeApplyFilters().catch((err) => {
          console.error("apply filters failed", err);
        }).finally(() => stopLoading());
      });

      endDateInput?.addEventListener("change", renderDateWarning);
      startDateInput?.addEventListener("change", renderDateWarning);

      includeTestCheckbox.addEventListener("change", () => {
        startLoading("Loading data…");
        applyFilters().finally(() => stopLoading());
      });

      exportCsvBtn.addEventListener("click", () => {
        const monthlyRows =
          isSingleFiSelected() && latestSingleFiBreakdowns?.monthly?.length
            ? latestSingleFiBreakdowns.monthly
            : [];
        const quarterlyRows =
          isSingleFiSelected() && latestSingleFiBreakdowns?.quarterly?.length
            ? latestSingleFiBreakdowns.quarterly
            : [];
        const weeklyRows =
          isSingleFiSelected() && latestSingleFiBreakdowns?.weekly?.length
            ? latestSingleFiBreakdowns.weekly
            : [];
        const dailyRows =
          isSingleFiSelected() && latestSingleFiBreakdowns?.daily?.length
            ? latestSingleFiBreakdowns.daily
            : [];
        const summaryRows =
          latestVisibleRows && latestVisibleRows.length
            ? latestVisibleRows
            : lastRenderContext?.perFi
            ? Object.values(lastRenderContext.perFi)
            : [];

        const csv = buildCsvDocument({
          summary: summaryRows,
          monthly: monthlyRows,
          quarterly: quarterlyRows,
          weekly: weeklyRows,
          daily: dailyRows,
          highlights: latestHighlights,
          partnerSummary: latestPartnerSummary,
          quarterSummary: latestQuarterSummary,
          start: lastRenderContext?.startDate || startDateInput.value || defaultStartDateStr,
          end: lastRenderContext?.endDate || endDateInput.value || defaultEndDateStr,
        });
        const start = ((startDateInput.value || lastRenderContext?.startDate || "start")).replace(/[^0-9-]/g, "");
        const end = ((endDateInput.value || lastRenderContext?.endDate || "end")).replace(/[^0-9-]/g, "");
        downloadCsv(`sis-funnel-${start}-to-${end}.csv`, csv);
      });

      fiFilterSelect?.addEventListener("change", () => {
        if (lastAggregated) {
          updateInstanceOptions(lastAggregated);
        }
        rerenderFromCache();
      });

      integrationSelect?.addEventListener("change", () => {
        if (lastAggregated) {
          updatePartnerOptions(lastAggregated);
          updateFiOptions(lastAggregated);
        } else if (fiFilterSelect) {
          fiFilterSelect.value = FI_ALL_VALUE;
        }
        rerenderFromCache();
      });

      partnerSelect?.addEventListener("change", () => {
        if (lastAggregated) {
          updateFiOptions(lastAggregated);
        } else if (fiFilterSelect) {
          fiFilterSelect.value = FI_ALL_VALUE;
        }
        rerenderFromCache();
      });

      instanceSelect?.addEventListener("change", () => {
        if (!instanceSelect) return;
        const selectedValues = Array.from(instanceSelect.selectedOptions).map(
          (opt) => opt.value
        );
        const hasAll = selectedValues.includes(INSTANCE_ALL_VALUE);
        if (hasAll && selectedValues.length > 1) {
          const allOption = instanceSelect.querySelector(
            `option[value="${INSTANCE_ALL_VALUE}"]`
          );
          if (allOption) {
            allOption.selected = false;
          }
        } else if (!hasAll && selectedValues.length === 0) {
          const allOption = instanceSelect.querySelector(
            `option[value="${INSTANCE_ALL_VALUE}"]`
          );
          if (allOption) {
            allOption.selected = true;
          }
        }
        rerenderFromCache();
      });

      init().catch((err) => {
        console.error("Init failed", err);
        stopLoading();
      });

      const presetSelect = document.getElementById("datePreset");
      if (presetSelect) {
        presetSelect.addEventListener("change", () => {
          const val = presetSelect.value || "last7";
          if (val) {
            applyPresetRange(val);
            safeApplyFilters();
          }
        });
      }

      applyDefaultDateRange(false);
      applyColumnTitles();
      (function ensureFilters(pageId){
        const run = () => {
          if (window.initFilters) {
            console.log("[filters] invoking initFilters for", pageId);
            window.initFilters(pageId);
          }
        };
        if (window.initFilters) return run();
        const candidates = [
          "/assets/js/filters.js?v=shared-fallback",
          "/public/assets/js/filters.js?v=shared-fallback",
        ];
        const loadNext = (idx) => {
          if (idx >= candidates.length) {
            console.error("[filters] unable to load shared filters script");
            return;
          }
          const s = document.createElement("script");
          s.src = candidates[idx] + "&ts=" + Date.now();
          s.onload = () => {
            console.log("[filters] loaded fallback script", candidates[idx]);
            run();
          };
          s.onerror = () => {
            console.warn("[filters] failed to load", candidates[idx]);
            loadNext(idx + 1);
          };
          document.head.appendChild(s);
        };
        loadNext(0);
      })("funnel");
    </script>
    <script src="./theme-toggle.js"></script>
  </body>
</html>
